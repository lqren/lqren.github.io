<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>享元模式</title>
    <url>/2017/12/03/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h5 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h5><p>享元模式，共享缘数据，就是将会重复创建的相同对象装在一个大池子里，当需要使用的时候直接从池子当中去取，而不再创建新的对象。</p>
<a id="more"></a>

<p>使用场景：</p>
<p>​    1、系统中存在大量相似对象。</p>
<p>​    2、细粒度的对象都具备较接近的外部状态，而且内部状态与环境无关，也就是说对象没有特定身份。</p>
<p>​    3、需要缓冲池的场景。</p>
<h5 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h5><p>类图：</p>
<p><img src="image-20200806100016274.png" alt="image-20200806100016274"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Ticket ticket1 &#x3D; TicketFactory.getTicket(&quot;深圳&quot;, &quot;成都&quot;);</span><br><span class="line">        ticket1.showTicketInfo(&quot;特等座&quot;);</span><br><span class="line">        Ticket ticket2 &#x3D; TicketFactory.getTicket(&quot;深圳&quot;, &quot;成都&quot;);</span><br><span class="line">        ticket2.showTicketInfo(&quot;一等座&quot;);</span><br><span class="line">        Ticket ticket3 &#x3D; TicketFactory.getTicket(&quot;深圳&quot;, &quot;成都&quot;);</span><br><span class="line">        ticket3.showTicketInfo(&quot;二等座&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Ticket &#123;</span><br><span class="line">    public void showTicketInfo(String seating);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TrainTicket implements Ticket &#123;</span><br><span class="line">    String from;</span><br><span class="line">    String to;</span><br><span class="line">    int price;</span><br><span class="line">    String seating;</span><br><span class="line"></span><br><span class="line">    public TrainTicket(String from, String to) &#123;</span><br><span class="line">        this.from &#x3D; from;</span><br><span class="line">        this.to &#x3D; to;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void showTicketInfo(String seating) &#123;</span><br><span class="line">        price &#x3D; new Random().nextInt(800);</span><br><span class="line">        System.out.println(&quot;购买从&quot; + from + &quot;到&quot; + to + &quot;的&quot; + seating + &quot;火车票，&quot; + &quot;票价：&quot; + price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TicketFactory &#123;</span><br><span class="line">    static ConcurrentHashMap&lt;String, Ticket&gt; ticketMap &#x3D; new ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public static Ticket getTicket(String from, String to) &#123;</span><br><span class="line">        String key &#x3D; from + &quot;-&quot; + to;</span><br><span class="line">        if (ticketMap.containsKey(key)) &#123;</span><br><span class="line">            System.out.println(&quot;使用类缓存池中的对象&quot;);</span><br><span class="line">            return ticketMap.get(key);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;创建类了新的对象&quot;);</span><br><span class="line">            TrainTicket trainTicket &#x3D; new TrainTicket(from, to);</span><br><span class="line">            ticketMap.put(key, trainTicket);</span><br><span class="line">            return trainTicket;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>享元模式，避免了重复的类似对象的创建，大大节省了内存开销，尤其是一些大的对象，在对象池当中会去维护一个key或者一个状态，当在集合中key存在或者状态为可重用状态时则直接返回对象池中的对象，否则创建新的对象。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>代理模式</title>
    <url>/2017/11/19/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h5 id="1、静态代理："><a href="#1、静态代理：" class="headerlink" title="1、静态代理："></a>1、静态代理：</h5><h6 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h6><p>代理模式又称为委托模式，为其他对象提供代理来控制对这个对象的访问。    </p>
<a id="more"></a>

<h6 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h6><p>类图：</p>
<p><img src="image-20200807145228102.png" alt="image-20200807145228102"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 静态代理</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new LogTankProxy(new TimeTankProxy(new Tank())).move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Movable&#123;</span><br><span class="line">    void move();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Tank implements Movable&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void move() &#123;</span><br><span class="line">        System.out.println(&quot;坦克...kakaka的跑&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class LogTankProxy implements Movable&#123;</span><br><span class="line">    private Movable tank;</span><br><span class="line"></span><br><span class="line">    public LogTankProxy(Movable tank) &#123;</span><br><span class="line">        this.tank &#x3D; tank;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void move() &#123;</span><br><span class="line">        System.out.println(&quot;坦克开启来来...&quot;);</span><br><span class="line">        tank.move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TimeTankProxy implements Movable&#123;</span><br><span class="line">    private Tank tank;</span><br><span class="line"></span><br><span class="line">    public TimeTankProxy(Tank tank) &#123;</span><br><span class="line">        this.tank &#x3D; tank;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void move() &#123;</span><br><span class="line">        long startTime &#x3D; System.currentTimeMillis();</span><br><span class="line">        tank.move();</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(new Random().nextInt(10000));</span><br><span class="line">            long endTime &#x3D; System.currentTimeMillis();</span><br><span class="line">            System.out.println((endTime-startTime)&#x2F;1000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>静态代理每个代理当中聚合了一个被代理对象，类似装饰器模式，但是静态代理只能代理我们清楚代理的方法。所以就有了动态代理。</p>
<h5 id="2、动态代理："><a href="#2、动态代理：" class="headerlink" title="2、动态代理："></a>2、动态代理：</h5><h6 id="概念：-1"><a href="#概念：-1" class="headerlink" title="概念："></a>概念：</h6><p>​    通过二进制字节码分析类的属性和方法。</p>
<h6 id="案例：-1"><a href="#案例：-1" class="headerlink" title="案例："></a>案例：</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Tank tank &#x3D; new Tank();</span><br><span class="line">        System.getProperties().put(&quot;jdk.proxy.ProxyGenerator.saveGeneratedFiles&quot;,&quot;true&quot;);</span><br><span class="line">        Movable m &#x3D; (Movable) Proxy.newProxyInstance(Tank.class.getClassLoader(),&#x2F;&#x2F;需要用到的classLoader</span><br><span class="line">                new Class[]&#123;Movable.class&#125;, &#x2F;&#x2F;动态生成的类需要实现的接口</span><br><span class="line">                new InvocationHandler() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">                System.out.println(&quot;method &quot;+method.getName()+&quot; start..&quot;);</span><br><span class="line">                Object o &#x3D; method.invoke(tank, args);</span><br><span class="line">                System.out.println(&quot;method &quot;+method.getName()+&quot; end&quot;);</span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        m.move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Movable&#123;</span><br><span class="line">    void move();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Tank implements Movable&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void move() &#123;</span><br><span class="line">        System.out.println(&quot;tank moving ....&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(new Random().nextInt(10000));</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h6><p>​    jdk的动态代理，必须要指定接口，只有指定了接口才知道要生成哪些方法。为解决jdk当中的这种情况，可以通过cglib实现动态代理，但是如果被代理类时final类型的，那么就只能通过asm来实现代理。</p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2017/11/17/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="单例模式-Sigleton-："><a href="#单例模式-Sigleton-：" class="headerlink" title="单例模式(Sigleton)："></a>单例模式(Sigleton)：</h2><h5 id="概念及应用"><a href="#概念及应用" class="headerlink" title="概念及应用"></a>概念及应用</h5><p>​    在内存中只允许一个实例对象，比如：各种Manager、各种Factory。</p>
<a id="more"></a>

<h5 id="实现方法：8种"><a href="#实现方法：8种" class="headerlink" title="实现方法：8种"></a>实现方法：8种</h5><h6 id="1-饿汉式："><a href="#1-饿汉式：" class="headerlink" title="1.饿汉式："></a>1.饿汉式：</h6><p>当类被加载到内存时就实例话对象，因为是static的，因此JVM可以保证线程安全（推荐使用）</p>
<p>缺点：不管是否使用，只要被加载到内存就会实例化对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Mgr01 &#123;</span><br><span class="line">    private static final Mgr01 INSTANCE &#x3D; new Mgr01();</span><br><span class="line">    private Mgr01()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Mgr01 getInstance()&#123;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="2-饿汉式等价写法："><a href="#2-饿汉式等价写法：" class="headerlink" title="2.饿汉式等价写法："></a>2.饿汉式等价写法：</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Mgr02 &#123;</span><br><span class="line">    private static Mgr02 INSTANCE ;</span><br><span class="line">    static &#123;</span><br><span class="line">        INSTANCE &#x3D; new Mgr02();</span><br><span class="line">    &#125;</span><br><span class="line">    private Mgr02()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Mgr02 getInstance()&#123;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="3-懒汉式："><a href="#3-懒汉式：" class="headerlink" title="3.懒汉式："></a>3.懒汉式：</h6><p>为了弥补前面饿汉式当中被加载进内存就初始化的问题，这里通过懒汉式的方式进行加载。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Mgr03 &#123;</span><br><span class="line">    private static Mgr03 INSTANCE;</span><br><span class="line">    private Mgr03()&#123;&#125;</span><br><span class="line">    public static Mgr03 getInstance()&#123;</span><br><span class="line">        if(INSTANCE &#x3D;&#x3D; null)&#123;</span><br><span class="line">            INSTANCE &#x3D; new Mgr03();</span><br><span class="line">        &#125;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点：这种懒汉式的方法会在多线程的情况下不能保证内存中只有一个实例</p>
<h6 id="4-懒汉式-方法上加锁"><a href="#4-懒汉式-方法上加锁" class="headerlink" title="4.懒汉式(方法上加锁):"></a>4.懒汉式(方法上加锁):</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Mgr04 &#123;</span><br><span class="line">    private static Mgr04 INSTANCE;</span><br><span class="line"></span><br><span class="line">    private Mgr04() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static synchronized Mgr04 getInstance() &#123;</span><br><span class="line">        if (INSTANCE &#x3D;&#x3D; null) &#123;</span><br><span class="line">            INSTANCE &#x3D; new Mgr04();</span><br><span class="line">        &#125;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点：方法上加锁，在多线程的情况下，每次都要判断锁，导致性能下降。</p>
<h6 id="5-懒汉式-作用域-："><a href="#5-懒汉式-作用域-：" class="headerlink" title="5.懒汉式(作用域)："></a>5.懒汉式(作用域)：</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Mgr05 &#123;</span><br><span class="line"></span><br><span class="line">    private static Mgr05 INSTANCE;</span><br><span class="line"></span><br><span class="line">    private Mgr05() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Mgr05 getInstance() &#123;</span><br><span class="line">        if (INSTANCE &#x3D;&#x3D; null) &#123;</span><br><span class="line">            synchronized (Mgr05.class) &#123;</span><br><span class="line">                INSTANCE &#x3D; new Mgr05();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点：上面这种直接减小同步代码块的作用域在多线程的情况下并不能保证单一实例。</p>
<h6 id="6-懒汉式-双重判断-："><a href="#6-懒汉式-双重判断-：" class="headerlink" title="6.懒汉式(双重判断)："></a>6.懒汉式(双重判断)：</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Mgr06 &#123;</span><br><span class="line"></span><br><span class="line">    private static volatile Mgr06 INSTANCE;</span><br><span class="line"></span><br><span class="line">    private Mgr06() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Mgr06 getInstance() &#123;</span><br><span class="line">        if (INSTANCE &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;判断是否加锁</span><br><span class="line">            synchronized (Mgr06.class) &#123;</span><br><span class="line">                if (INSTANCE &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;判断对象是否实例化</span><br><span class="line">                    INSTANCE &#x3D; new Mgr06();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="7-静态内部类："><a href="#7-静态内部类：" class="headerlink" title="7.静态内部类："></a>7.静态内部类：</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Mgr07 &#123;</span><br><span class="line">    private static class Mgr07Holder&#123;</span><br><span class="line">        private static final Mgr07 INSTANCE &#x3D; new Mgr07();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Mgr07()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Mgr07 getInstance()&#123;</span><br><span class="line">        return Mgr07Holder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：当类被加载到内存时并不会直接实例化对象，达到了懒汉式的效果，同时JVM保证了多线程安全问题。</p>
<h6 id="8-枚举方式："><a href="#8-枚举方式：" class="headerlink" title="8. 枚举方式："></a>8. 枚举方式：</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum  Mgr08 &#123;</span><br><span class="line">    INSTANCE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>保证实例单一的同时还可以防止被反序列化。前面的其他方式都可以通过反射的方式创建多个实例。枚举类不会被反序列化的原因是因为枚举不存在构造函数，所以不能实例化。</p>
<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>单例模式就是为了保证在内存中实例的唯一性，通常我们写单例模式比较完美的写法：饿汉式、双重判断+锁+volatile的懒汉式、静态内部类、枚举方式。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>六大设计原则</title>
    <url>/2017/11/10/%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h5 id="1、单一职责-："><a href="#1、单一职责-：" class="headerlink" title="1、单一职责 ："></a>1、单一职责 ：</h5><p>​        就一个类而言，应该仅有一个引起他变化的原因，一个类应该是一组相关性很高的函数、数据的封装</p>
<h5 id="2、开闭原则："><a href="#2、开闭原则：" class="headerlink" title="2、开闭原则："></a>2、开闭原则：</h5><p>​        软件中的对象对于扩展是开放的，对于修改应该是关闭的</p>
<a id="more"></a>

<h5 id="3、里氏替换原则"><a href="#3、里氏替换原则" class="headerlink" title="3、里氏替换原则"></a>3、里氏替换原则</h5><p>​        任何父类出现的地方都可以被子类替换。</p>
<h5 id="4、依赖倒置原则："><a href="#4、依赖倒置原则：" class="headerlink" title="4、依赖倒置原则："></a>4、依赖倒置原则：</h5><p>​        模块之间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或者抽象类产生的。</p>
<h5 id="5、接口隔离原则："><a href="#5、接口隔离原则：" class="headerlink" title="5、接口隔离原则："></a>5、接口隔离原则：</h5><p>​        客户端不需要依赖他不需要的接口，类间的依赖关系应该建立在最小的接口上</p>
<h5 id="6、迪米特法则："><a href="#6、迪米特法则：" class="headerlink" title="6、迪米特法则："></a>6、迪米特法则：</h5><p>​        一个对象应该对其他对象有最少的了解</p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂模式</title>
    <url>/2017/11/25/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h5 id="概念及应用"><a href="#概念及应用" class="headerlink" title="概念及应用:"></a>概念及应用:</h5><p>任何可以产生对象的方法或类，都可以称为工厂</p>
<h5 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h5><h6 id="1、工厂方法-Factory-method-："><a href="#1、工厂方法-Factory-method-：" class="headerlink" title="1、工厂方法(Factory method)："></a>1、工厂方法(Factory method)：</h6><p>​        概念：简单工厂就是对于不同产品都有自己的工厂方法创建相应的实例对象。</p>
<a id="more"></a>

<p>​        案例：</p>
<p>​        类图：</p>
<p><img src="image-20200803105430375.png" alt="image-20200803105430375"></p>
<p>Moveable：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Moveable &#123;</span><br><span class="line">    void go();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        Car：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Car implements Moveable&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void go()&#123;</span><br><span class="line">        System.out.println(&quot;Car go ....&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        plane：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Plane implements Moveable&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void go()&#123;</span><br><span class="line">        System.out.println(&quot;sou sou sou ....&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>工厂类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SimpleVehicleFactory &#123;</span><br><span class="line">    public Car createCar()&#123;</span><br><span class="line">        return new Car();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Plane createPlane()&#123;</span><br><span class="line">        return new Plane();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Broom createBroom()&#123;</span><br><span class="line">        return new Broom();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SimpleVehicleFactory simpleVehicleFactory &#x3D; new SimpleVehicleFactory();</span><br><span class="line">        simpleVehicleFactory.createCar().go();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2、抽象工厂-abstractFactory-："><a href="#2、抽象工厂-abstractFactory-：" class="headerlink" title="2、抽象工厂(abstractFactory)："></a>2、抽象工厂(abstractFactory)：</h6><p>​    概念：能创建一个产品族。工厂抽象，不同的产品族对应不同的工厂实现，产品抽象，具体的产品各自实现。</p>
<p>类图：</p>
<p><img src="%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/image-20200803111056423.png" alt="image-20200803111056423"></p>
<p>​    </p>
<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>工厂方法模式对于产品的扩展是很方便的，只需要添加产品和产品工厂即可。但是如果是一个产品族的扩展，抽象工厂模式比较容易扩展。</p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>建造者模式</title>
    <url>/2017/12/01/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="建造者模式-Builder"><a href="#建造者模式-Builder" class="headerlink" title="建造者模式(Builder):"></a>建造者模式(Builder):</h2><h5 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h5><h5 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private Person()&#123;&#125;</span><br><span class="line">    int id;</span><br><span class="line">    int age;</span><br><span class="line">    String name;</span><br><span class="line">    double weight;</span><br><span class="line">    int score;</span><br><span class="line">    Location loc;</span><br><span class="line">    </span><br><span class="line">    public static class PersonBuilder&#123;</span><br><span class="line">        private Person p &#x3D; new Person();</span><br><span class="line">        public PersonBuilder basicInfo(int id,String name,int age)&#123;</span><br><span class="line">            p.id &#x3D; id;</span><br><span class="line">            p.name &#x3D; name;</span><br><span class="line">            p.age &#x3D; age;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        public PersonBuilder weight(double weight)&#123;</span><br><span class="line">            p.weight &#x3D; weight;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        public PersonBuilder score(int score)&#123;</span><br><span class="line">            p.score &#x3D; score;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        public PersonBuilder loc(String street,String roomNo)&#123;</span><br><span class="line">            p.loc &#x3D; new Location(street,roomNo);</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        public Person build()&#123;</span><br><span class="line">            return p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Location&#123;</span><br><span class="line">    String street;</span><br><span class="line">    String roomNo;</span><br><span class="line"></span><br><span class="line">    public Location(String street, String roomNo) &#123;</span><br><span class="line">        this.street &#x3D; street;</span><br><span class="line">        this.roomNo &#x3D; roomNo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>builder模式就是在需要被创建出的对象中提供静态内部类，在内部类当中创建实例，提供为每个属性赋值的方法，并返回静态内部类，最后在静态内部类当中提供build()，返回需要创建的对象即可。</p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>桥接模式</title>
    <url>/2017/12/02/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h5 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h5><p>抽象与具体之间分开发展，抽象当中聚合具体的实现，相互之间不容易产生类爆炸情况。</p>
<a id="more"></a>

<h5 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h5><p>类图</p>
<p><img src="image-20200826103756075.png" alt="image-20200826103756075"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Gift &#123;</span><br><span class="line">    GiftImpl giftImpl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class GiftImpl &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class WarmGift extends Gift&#123;</span><br><span class="line">    public WarmGift(GiftImpl giftImpl)&#123;</span><br><span class="line">        this.giftImpl &#x3D; giftImpl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ColdGift extends Gift&#123;</span><br><span class="line">    public ColdGift(GiftImpl giftImpl) &#123;</span><br><span class="line">        this.giftImpl &#x3D; giftImpl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Flower extends GiftImpl&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Book extends GiftImpl&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class GG &#123;</span><br><span class="line">    public void chase()&#123;</span><br><span class="line">        ColdGift coldGift &#x3D; new ColdGift(new Flower());</span><br><span class="line">        give(new MM(),coldGift);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void give(MM mm,Gift gift)&#123;</span><br><span class="line">        System.out.println(gift+&quot;gived!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MM &#123;</span><br><span class="line">    String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>如果一个场景，抽象的类别也在不断的扩展，具体的也在不断的扩展，可以用桥接模式。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>模版方法模式</title>
    <url>/2017/11/17/%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h5 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h5><p>模版方法其实就是钩子函数，父类中的方法定义了调用一些方法的调用步骤，这些步骤又延迟到子类中去实现。</p>
<a id="more"></a>

<h5 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        F f &#x3D; new C();</span><br><span class="line">        f.m();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">abstract class F&#123;</span><br><span class="line">    void m()&#123;</span><br><span class="line">        op1();</span><br><span class="line">        op2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    abstract void op1();</span><br><span class="line">    abstract void op2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C extends F&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void op1() &#123;</span><br><span class="line">        System.out.println(&quot;op1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void op2() &#123;</span><br><span class="line">        System.out.println(&quot;op2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>模版方法就是在类中定义了方法的执行顺序，但是这些方法额具体实现在子类中。钩子函数也是模版方法。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>策略模式</title>
    <url>/2017/11/18/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="策略模式-Strategy-："><a href="#策略模式-Strategy-：" class="headerlink" title="策略模式(Strategy)："></a>策略模式(Strategy)：</h2><h5 id="概念及应用"><a href="#概念及应用" class="headerlink" title="概念及应用:"></a>概念及应用:</h5><p>定义了一系列算法，将每个算法封装起来，做一件事可以采用不同的方式。    Android动画中的插值器。</p>
<a id="more"></a>

<h5 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h5><p>   类图：<img src="image-20200803112833812.png" alt="image-20200803112833812"></p>
<p>Sorter:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Sorter&lt;T&gt; &#123;</span><br><span class="line">    public void sort(T[] arr, Comparator&lt;T&gt; comparator) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line">            int minPos &#x3D; i;</span><br><span class="line">            for (int j &#x3D; i + 1; j &lt; arr.length; j++) &#123;</span><br><span class="line">                minPos &#x3D; comparator.compare(arr[j], arr[minPos]) &#x3D;&#x3D; -1 ? j : minPos;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            swap(arr, i, minPos);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void swap(T[] arr, int i, int j) &#123;</span><br><span class="line">        T temp &#x3D; arr[i];</span><br><span class="line">        arr[i] &#x3D; arr[j];</span><br><span class="line">        arr[j] &#x3D; temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Comparator:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Comparator&lt;T&gt; &#123;</span><br><span class="line">    int compare(T t1,T t2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CatWeightComparator:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CatWeightComparator implements Comparator&lt;Cat&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(Cat t1, Cat t2) &#123;</span><br><span class="line">        if (t1.weight &gt; t2.weight) return 1;</span><br><span class="line">        else if (t1.weight &lt; t2.weight) return -1;</span><br><span class="line">        else</span><br><span class="line">            return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CatHeightComparator:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CatHeightComparator implements Comparator&lt;Cat&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(Cat t1, Cat t2) &#123;</span><br><span class="line">        if (t1.height &lt; t2.height) return 1;</span><br><span class="line">        else if (t1.height &#x3D;&#x3D; t2.height) return 0;</span><br><span class="line">        else return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DogWeightComparator:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class DogWeightComparator implements Comparator&lt;Dog&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(Dog t1, Dog t2) &#123;</span><br><span class="line">        if (t1.weight &gt; t2.weight) return 1;</span><br><span class="line">        else if (t1.weight &lt; t2.weight) return -1;</span><br><span class="line">        else</span><br><span class="line">            return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">&#x2F;&#x2F;        Cat[] cats &#x3D; &#123;new Cat(1,1),new Cat(3,3),new Cat(2,2)&#125;;</span><br><span class="line">&#x2F;&#x2F;        Sorter&lt;Cat&gt; sorter &#x3D; new Sorter&lt;&gt;();</span><br><span class="line">&#x2F;&#x2F;        sorter.sort(cats,new CatWeightComparator());</span><br><span class="line">&#x2F;&#x2F;        System.out.println(Arrays.toString(cats));</span><br><span class="line"></span><br><span class="line">        Dog[] dogs &#x3D; &#123;new Dog(2),new Dog(1),new Dog(4)&#125;;</span><br><span class="line">        Sorter&lt;Dog&gt; sorter1 &#x3D; new Sorter&lt;&gt;();</span><br><span class="line">        sorter1.sort(dogs,new DogWeightComparator());</span><br><span class="line">        System.out.println(Arrays.toString(dogs));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>所谓策略模式，封装的是做一件事的不同方式。</p>
<p>扩展：在1.8之后允许接口当中存在方法的实现，但是方法必须是default修饰，default关键字是为了兼容之前版本，实现类只需要实现abstract的方法，default的方法可以不被实现。</p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>组合模式</title>
    <url>/2017/12/12/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h5 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h5><p>​    就是一种树状结构，有叶子节点和分支，分支下面又有叶子节点和分支。</p>
<a id="more"></a>

<h5 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h5><p>类图：</p>
<p>​    <img src="image-20200806084442400.png" alt="image-20200806084442400"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BranchNode root &#x3D; new BranchNode(&quot;root&quot;);</span><br><span class="line">        BranchNode chapter1 &#x3D; new BranchNode(&quot;chapter1&quot;);</span><br><span class="line">        BranchNode chapter2 &#x3D; new BranchNode(&quot;chapter2&quot;);</span><br><span class="line"></span><br><span class="line">        Leaf c11 &#x3D; new Leaf(&quot;c11&quot;);</span><br><span class="line">        Leaf c12 &#x3D; new Leaf(&quot;c12&quot;);</span><br><span class="line"></span><br><span class="line">        BranchNode section21 &#x3D; new BranchNode(&quot;section21&quot;);</span><br><span class="line">        Leaf c211 &#x3D; new Leaf(&quot;c211&quot;);</span><br><span class="line">        Leaf c212 &#x3D; new Leaf(&quot;c212&quot;);</span><br><span class="line"></span><br><span class="line">        root.add(chapter1);</span><br><span class="line">        root.add(chapter2);</span><br><span class="line">        chapter1.add(c11);</span><br><span class="line">        chapter1.add(c12);</span><br><span class="line">        chapter2.add(section21);</span><br><span class="line">        section21.add(c211);</span><br><span class="line">        section21.add(c212);</span><br><span class="line"></span><br><span class="line">        tree(root,0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void tree(Node node,int depth)&#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; depth; i++) &#123;</span><br><span class="line">            System.out.print(&quot;--&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        node.print();</span><br><span class="line">        if(node instanceof BranchNode)&#123;</span><br><span class="line">            for(Node n :((BranchNode) node).nodes)&#123;</span><br><span class="line">                tree(n,depth+1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract class Node &#123;</span><br><span class="line">    abstract void print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Leaf extends Node&#123;</span><br><span class="line">    private String content;</span><br><span class="line">    public Leaf(String content)&#123;</span><br><span class="line">        this.content &#x3D; content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void print() &#123;</span><br><span class="line">        System.out.println(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BranchNode extends Node&#123;</span><br><span class="line">    public List&lt;Node&gt; nodes &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    public BranchNode(String name)&#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    void print() &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void add(Node node)&#123;</span><br><span class="line">        nodes.add(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>组合模式就是一个树状结构，里面可以有叶子节点和分支节点，分支节点当中又可以有分支节点和叶子节点，可以无穷下去。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>装饰器模式</title>
    <url>/2017/12/10/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h5 id="概念及应用场景："><a href="#概念及应用场景：" class="headerlink" title="概念及应用场景："></a>概念及应用场景：</h5><p>动态给一个对象添加额外的职责，从增加功能的角度说，新增加功能比生成子类更加灵活。</p>
<a id="more"></a>

<h5 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h5><p>类图：<img src="image-20200803174118003.png" alt="image-20200803174118003"></p>
<p>具体实现：</p>
<p>​    组件抽象类Component：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class Component &#123;</span><br><span class="line">    abstract void operate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    组件具体实现ConcreteComponent：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ConcreteComponent extends Component&#123;</span><br><span class="line">    @Override</span><br><span class="line">    void operate() &#123;</span><br><span class="line">        &#x2F;&#x2F;具体逻辑</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    装饰者抽象类Decorator：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class Decorator extends Component&#123;</span><br><span class="line">    private Component component;</span><br><span class="line">    public Decorator(Component component)&#123;</span><br><span class="line">        this.component &#x3D; component;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    void operate() &#123;</span><br><span class="line">        component.operate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>装饰者具体实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ConcreteDecoratorA extends Decorator&#123;</span><br><span class="line">    public ConcreteDecoratorA(Component component) &#123;</span><br><span class="line">        super(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void operate() &#123;</span><br><span class="line">        operateA();</span><br><span class="line">        super.operate();</span><br><span class="line">        operateB();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void operateA() &#123;</span><br><span class="line">        &#x2F;&#x2F;装饰方法</span><br><span class="line">    &#125;</span><br><span class="line">    public void operateB() &#123;</span><br><span class="line">        &#x2F;&#x2F;装饰方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ConcreteDecoratorB extends Decorator&#123;</span><br><span class="line">    public ConcreteDecoratorB(Component component) &#123;</span><br><span class="line">        super(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void operate() &#123;</span><br><span class="line">        super.operate();</span><br><span class="line">        operateA();</span><br><span class="line">        operateB();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void operateA() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void operateB()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ConcreteComponent concreteComponent &#x3D; new ConcreteComponent();</span><br><span class="line">        ConcreteDecoratorA decorator &#x3D; new ConcreteDecoratorA(concreteComponent);</span><br><span class="line">        decorator.operate();</span><br><span class="line"></span><br><span class="line">        ConcreteDecoratorB decoratorB &#x3D; new ConcreteDecoratorB(concreteComponent);</span><br><span class="line">        decoratorB.operate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>所谓的装饰器模式是动态的为对象进行功能的增强，被装饰者与抽象的装饰者都继承自同一个抽象组件，抽象装饰者中动态传入了被装饰者，在装饰者的具体实现当中，原有的方法中又调用了增强功能的方法。Java中的流就是典型的装饰器模式</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>观察者模式</title>
    <url>/2017/11/26/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h5 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h5><p>定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，所有依赖于他的对象都会得到通知并自动更新。</p>
<h5 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h5><h5 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h5><p>类图：</p>
<p><img src="image-20200805144209128.png" alt="image-20200805144209128"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child&#123;</span><br><span class="line">    private List&lt;Observer&gt; observers &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    &#123;</span><br><span class="line">        observers.add(new Mom());</span><br><span class="line">        observers.add(new Dad());</span><br><span class="line">    &#125;</span><br><span class="line">    public void wakeUp()&#123;</span><br><span class="line">        WakeEvent wakeEvent &#x3D; new WakeEvent(System.currentTimeMillis(), &quot;bed&quot;, this);</span><br><span class="line">        for (Observer observer : observers) &#123;</span><br><span class="line">            observer.wakeUp(wakeEvent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class WakeEvent&#123;</span><br><span class="line">    long timeStamp;</span><br><span class="line">    String loc;</span><br><span class="line">    Child source;</span><br><span class="line"></span><br><span class="line">    public WakeEvent(long timeStamp,String loc,Child source)&#123;</span><br><span class="line">        this.timeStamp &#x3D; timeStamp;</span><br><span class="line">        this.loc &#x3D; loc;</span><br><span class="line">        this.source &#x3D; source;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Observer&#123;</span><br><span class="line">    void wakeUp(WakeEvent event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Mom implements Observer&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void wakeUp(WakeEvent event) &#123;</span><br><span class="line">        hug();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void hug() &#123;</span><br><span class="line">        System.out.println(&quot;mom hug...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dad implements Observer&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void wakeUp(WakeEvent event) &#123;</span><br><span class="line">        feed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void feed() &#123;</span><br><span class="line">        System.out.println(&quot;dad feed...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>被观察者中添加了所有的观察者，当被观察者发生变化的时候会遍历所有的观察者发生变化。所有的Observer、listener、hook method、Callback都是观察者模式。</p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>访问者模式</title>
    <url>/2017/11/23/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="访问者模式-Visitor"><a href="#访问者模式-Visitor" class="headerlink" title="访问者模式(Visitor):"></a>访问者模式(Visitor):</h2><h5 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h5><p>​    当内部固定，需要根据不同需求得到不同结果的时候使用。如果内部结构不固定，那么该设计模式就不合适。</p>
<a id="more"></a>

<h5 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h5><p>类图：</p>
<p><img src="image-20200809184953351.png" alt="image-20200809184953351"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Computer &#123;</span><br><span class="line">    ComputerPart cpu &#x3D; new Cpu();</span><br><span class="line">    ComputerPart memory &#x3D; new Memory();</span><br><span class="line">    ComputerPart keyBord &#x3D; new KeyBord();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        PersonnelVisitor personnelVisitor &#x3D; new PersonnelVisitor();</span><br><span class="line">        new Computer().accept(personnelVisitor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void accept(Visitor v) &#123;</span><br><span class="line">        cpu.accept(v);</span><br><span class="line">        memory.accept(v);</span><br><span class="line">        keyBord.accept(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    abstract class ComputerPart &#123;</span><br><span class="line">        abstract void accept(Visitor v);</span><br><span class="line"></span><br><span class="line">        abstract double getPrice();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    interface Visitor &#123;</span><br><span class="line">        void visitCpu(ComputerPart cpu);</span><br><span class="line"></span><br><span class="line">        void visitMemory(ComputerPart memory);</span><br><span class="line"></span><br><span class="line">        void visitKeyBord(ComputerPart keyBord);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Cpu extends ComputerPart &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        void accept(Visitor v) &#123;</span><br><span class="line">            v.visitCpu(this);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        double getPrice() &#123;</span><br><span class="line">            return 300;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class KeyBord extends ComputerPart &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        void accept(Visitor v) &#123;</span><br><span class="line">            v.visitKeyBord(this);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        double getPrice() &#123;</span><br><span class="line">            return 100;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Memory extends ComputerPart &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        void accept(Visitor v) &#123;</span><br><span class="line">            v.visitMemory(this);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        double getPrice() &#123;</span><br><span class="line">            return 200;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class PersonnelVisitor implements Visitor &#123;</span><br><span class="line">        double totalPrice;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void visitCpu(ComputerPart cpu) &#123;</span><br><span class="line">            totalPrice +&#x3D; cpu.getPrice() * .6f;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void visitMemory(ComputerPart memory) &#123;</span><br><span class="line">            totalPrice +&#x3D; memory.getPrice() * .5f;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void visitKeyBord(ComputerPart keyBord) &#123;</span><br><span class="line">            totalPrice +&#x3D; keyBord.getPrice() * .7f;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class CropVisitor implements Visitor &#123;</span><br><span class="line">        double totalPrice;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void visitCpu(ComputerPart cpu) &#123;</span><br><span class="line">            totalPrice +&#x3D; cpu.getPrice() * .9f;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void visitMemory(ComputerPart memory) &#123;</span><br><span class="line">            totalPrice +&#x3D; memory.getPrice() * .9f;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void visitKeyBord(ComputerPart keyBord) &#123;</span><br><span class="line">            totalPrice +&#x3D; keyBord.getPrice() * .9f;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>访问者模式只适用于当内部结构固定的情况下使用，如果内部结构经常发生变化，则不适合使用。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>责任链模式</title>
    <url>/2017/12/05/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h5 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h5><p>Chain Of Responsibility,最普通的责任链就是每个可处理的过滤器都可以对原始数据做处理，多个链条也可以直接进行连接。但最完善的责任链模式则是需要对请求和响应进行处理，每个链上的对象都可以终止请求或者响应。</p>
<a id="more"></a>

<h5 id="实现方式及案例："><a href="#实现方式及案例：" class="headerlink" title="实现方式及案例："></a>实现方式及案例：</h5><p>在我们的案例中我们需要满足，当一个request执行完成之后，满足条件就继续下一次request处理，当所有的request执行完成之后，需要将response倒过来执行，即后添加的response需要先执行。</p>
<p>那么在实现的过程中，我们可以在每个Filter当中都传入我们的chain引用，当每个filter满足条件时选择是否要执行chain的doFilter()，在FilterChain中需要对当前执行到那个Filter进行位置记录，方便下次调用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ServletMain &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Request request &#x3D; new Request();</span><br><span class="line">        request.str &#x3D; &quot;大家好:),&lt;script&gt;欢迎访问我的个人网站：roqy.com，大家都是996&quot;;</span><br><span class="line"></span><br><span class="line">        Response response &#x3D; new Response();</span><br><span class="line">        response.str &#x3D; &quot;response&quot;;</span><br><span class="line">        FilterChain chain &#x3D; new FilterChain();</span><br><span class="line">        chain.add(new FaceFilter())</span><br><span class="line">                .add(new HTMLFilter())</span><br><span class="line">                .add(new HttpFilter())</span><br><span class="line">                .doFilter(request,response);</span><br><span class="line">        System.out.println(request.str);</span><br><span class="line">        System.out.println(response.str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Request &#123;</span><br><span class="line">    String str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Response &#123;</span><br><span class="line">    String str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Filter &#123;</span><br><span class="line">    void doFilter(Request request, Response response, FilterChain chain);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class FilterChain&#123;</span><br><span class="line">    int index &#x3D; 0;&#x2F;&#x2F;记录当前调用到第几个过滤器</span><br><span class="line">    private List&lt;Filter&gt; filters &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public FilterChain add(Filter filter) &#123;</span><br><span class="line">        filters.add(filter);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void doFilter(Request request, Response response) &#123;</span><br><span class="line">        if (index &#x3D;&#x3D; filters.size()) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        Filter filter &#x3D; filters.get(index);</span><br><span class="line">        index++;</span><br><span class="line">        filter.doFilter(request, response,this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class FaceFilter implements Filter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(Request request, Response response, FilterChain chain) &#123;</span><br><span class="line">        request.str &#x3D; (request.str.replace(&quot;:)&quot;, &quot;^V^&quot;));</span><br><span class="line">        chain.doFilter(request,response);</span><br><span class="line">        response.str +&#x3D; &quot;---FaceFilter()&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class HTMLFilter implements Filter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(Request request, Response response, FilterChain chain) &#123;</span><br><span class="line">        request.str &#x3D; request.str.replace(&quot;&lt;&quot;, &quot;[&quot;);</span><br><span class="line">        request.str &#x3D; request.str.replace(&quot;&gt;&quot;, &quot;]&quot;);</span><br><span class="line">        chain.doFilter(request,response);</span><br><span class="line">        response.str +&#x3D; &quot;---HTMLFilter()&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class HttpFilter implements Filter&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(Request request, Response response, FilterChain chain) &#123;</span><br><span class="line">        request.str &#x3D; request.str.replace(&quot;roqy.com&quot;, &quot;https:&#x2F;&#x2F;www.roqy.com&quot;);</span><br><span class="line">        response.str+&#x3D;&quot;---HttpFilter()&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>整个责任链模式，类似于一个递归的过程，每一个filter都传入了一个chain引用，在当前filter当中选择性的决定是否要调用下一个filter，在chain中维护着当前调用的filter在集合中的位置。当没有filter再去主动调用的时候就会自动倒序调用response。执行顺序request1-&gt;request2-&gt;request3 -&gt;response3-&gt;response2-&gt;response1。</p>
<p>优点：可以对请求者和处理者关系解耦，提高代码灵活性</p>
<p>缺点：在对链中请求处理者的遍历，如果处理者太多那么遍历就必定会影响性能，在一些递归中调用要慎重。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代器模式</title>
    <url>/2017/11/20/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="迭代器模式-iterator-："><a href="#迭代器模式-iterator-：" class="headerlink" title="迭代器模式(iterator)："></a>迭代器模式(iterator)：</h2><h5 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h5><p>每个集合或者容器的遍历方式不同，所以各自集合的遍历方式交给各自集合自己实现，但抽象出遍历器，每个集合都有自己的遍历器，遍历器获取方式相同。</p>
<a id="more"></a>

<h5 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h5><p>类图：</p>
<p><img src="image-20200808214016102.png" alt="image-20200808214016102"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Collection collection &#x3D; new ArrayList_();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">            collection.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">&#x2F;&#x2F;        System.out.println(collection.size());</span><br><span class="line"></span><br><span class="line">        Iterator iterator &#x3D; collection.iterator();</span><br><span class="line">        while (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ArrayList_&lt;E&gt; implements Collection&lt;E&gt; &#123;</span><br><span class="line">    private E[] list &#x3D; (E[])new Object[10];</span><br><span class="line">    private int index;</span><br><span class="line"></span><br><span class="line">    public void add(E o) &#123;</span><br><span class="line">        if (index &#x3D;&#x3D; list.length) &#123;</span><br><span class="line">            E[] newList &#x3D; (E[])new Object[list.length * 2];</span><br><span class="line">            System.arraycopy(list, 0, newList, 0, list.length);</span><br><span class="line">            list &#x3D; newList;</span><br><span class="line">        &#125;</span><br><span class="line">        list[index] &#x3D; o;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Iterator iterator() &#123;</span><br><span class="line">        return new ArrayListIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class ArrayListIterator implements Iterator &#123;</span><br><span class="line">        private int currentIndex &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean hasNext() &#123;</span><br><span class="line">            if (currentIndex &gt;&#x3D; index)</span><br><span class="line">                return false;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Object next() &#123;</span><br><span class="line">            Object o &#x3D; list[currentIndex];</span><br><span class="line">            currentIndex++;</span><br><span class="line">            return o;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class LikeList implements Collection &#123;</span><br><span class="line">    Node head, tail;</span><br><span class="line">    private int size;</span><br><span class="line"></span><br><span class="line">    private class Node&lt;E&gt; &#123;</span><br><span class="line">        private E o;</span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        public Node(E o) &#123;</span><br><span class="line">            this.o &#x3D; o;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void add(Object o) &#123;</span><br><span class="line">        Node node &#x3D; new Node(o);</span><br><span class="line">        node.next &#x3D; null;</span><br><span class="line">        if (head &#x3D;&#x3D; null) &#123;</span><br><span class="line">            head &#x3D; tail &#x3D; node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tail.next &#x3D; node;</span><br><span class="line">        tail &#x3D; node;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Iterator iterator() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Collection&lt;E&gt; &#123;</span><br><span class="line">    void add(E e);</span><br><span class="line"></span><br><span class="line">    int size();</span><br><span class="line"></span><br><span class="line">    Iterator iterator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Iterator&lt;E&gt; &#123;</span><br><span class="line">    boolean hasNext();</span><br><span class="line"></span><br><span class="line">    E next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>迭代器模式主要是用在集合中的遍历中，不做其他过多总结。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Retrofit2.9.0源码分析</title>
    <url>/2021/02/18/Retrofit%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="一、基本概念及使用："><a href="#一、基本概念及使用：" class="headerlink" title="一、基本概念及使用："></a>一、基本概念及使用：</h1><h2 id="1、概念："><a href="#1、概念：" class="headerlink" title="1、概念："></a>1、概念：</h2><p>​        Retrofit是对OkHttp的进一步封装，内部使用了大量的设计模式，注解和反射</p>
<h2 id="2、基本使用："><a href="#2、基本使用：" class="headerlink" title="2、基本使用："></a>2、基本使用：</h2><p>​        gradle引用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">implementation(&quot;com.squareup.retrofit2:retrofit:2.9.0&quot;)</span><br><span class="line">implementation(&quot;com.squareup.retrofit2:converter-gson:2.9.0&quot;)</span><br></pre></td></tr></table></figure>

<a id="more"></a>      

<p>  代码使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> val retrofit &#x3D; Retrofit.Builder().baseUrl(&quot;&quot;)</span><br><span class="line">            .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">&#x2F;&#x2F;            .addCallAdapterFactory()</span><br><span class="line">            .build()</span><br><span class="line">        val clientService &#x3D; retrofit.create(ServerService::class.java)</span><br><span class="line"></span><br><span class="line">        clientService.getUserInfo(&quot;test&quot;).enqueue(object :Callback&lt;Response&lt;String&gt;&gt;&#123;</span><br><span class="line">            override fun onFailure(call: Call&lt;Response&lt;String&gt;&gt;, t: Throwable) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            override fun onResponse(call: Call&lt;Response&lt;String&gt;&gt;,response: Response&lt;Response&lt;String&gt;&gt;) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<h1 id="二、源码分析："><a href="#二、源码分析：" class="headerlink" title="二、源码分析："></a>二、源码分析：</h1><p>​    看源码最好从最后一句开始去看，这样才有目的性，切记不要去纠结源码细节，否则会陷进去出不来</p>
<h2 id="1、enqueue-："><a href="#1、enqueue-：" class="headerlink" title="1、enqueue()："></a>1、enqueue()：</h2><p>​       clientService.getUserInfo(“test”).enqueue()，进去之后会发现这是个接口中的方法，那么这里就看不了了</p>
<h2 id="2、clientService-getUserInfo-“test”"><a href="#2、clientService-getUserInfo-“test”" class="headerlink" title="2、clientService.getUserInfo(“test”)"></a>2、clientService.getUserInfo(“test”)</h2><p>​       因为前面走不下去，那么再看他前面一句：clientService.getUserInfo(“test”)，这个方法只是我们自己定义的Service中的接口方法</p>
<h2 id="3、retrofit-create-ServerService-class-java"><a href="#3、retrofit-create-ServerService-class-java" class="headerlink" title="3、retrofit.create(ServerService::class.java)"></a>3、retrofit.create(ServerService::class.java)</h2><p>因为前面都是接口方法，所以我们只能再去看前面的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">retrofit.create(ServerService::class.java)</span><br><span class="line"></span><br><span class="line">  public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123;</span><br><span class="line">    &#x2F;&#x2F;这个方法是去校验传入的service是不是接口</span><br><span class="line">    validateServiceInterface(service);</span><br><span class="line">    &#x2F;&#x2F;通过动态代理创建传入的service对象的代理对象，这里返回的就是这个代理对象</span><br><span class="line">    return (T)</span><br><span class="line">        Proxy.newProxyInstance(</span><br><span class="line">            &#x2F;&#x2F;传入一个ClassLoader</span><br><span class="line">            service.getClassLoader(),</span><br><span class="line">            &#x2F;&#x2F;传入我们需要代理的接口，可以是多个</span><br><span class="line">            new Class&lt;?&gt;[] &#123;service&#125;,</span><br><span class="line">            &#x2F;&#x2F;新建一个InvocationHandler，会重写invoke()</span><br><span class="line">            new InvocationHandler() &#123;</span><br><span class="line">            &#x2F;&#x2F;获取平台方法，平台方法不会走反射解析的方法</span><br><span class="line">              private final Platform platform &#x3D; Platform.get();</span><br><span class="line">              private final Object[] emptyArgs &#x3D; new Object[0];</span><br><span class="line"></span><br><span class="line">              @Override</span><br><span class="line">              public @Nullable Object invoke(Object proxy, Method method, @Nullable Object[] args)</span><br><span class="line">                  throws Throwable &#123;</span><br><span class="line">                &#x2F;&#x2F; If the method is a method from Object then defer to normal invocation.</span><br><span class="line">                if (method.getDeclaringClass() &#x3D;&#x3D; Object.class) &#123;</span><br><span class="line">                  return method.invoke(this, args);</span><br><span class="line">                &#125;</span><br><span class="line">                args &#x3D; args !&#x3D; null ? args : emptyArgs;</span><br><span class="line">                return platform.isDefaultMethod(method)</span><br><span class="line">                    ? platform.invokeDefaultMethod(method, service, proxy, args)</span><br><span class="line">                    &#x2F;&#x2F;自己定义的方法，会先看缓存中存不存在，如果不存在，则会对方法的各种注解和参数进行解析，解析完之后返回一个ServiceMethod</span><br><span class="line">                    : loadServiceMethod(method).invoke(args);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、ServiceMethod-lt-gt-loadServiceMethod-Method-method"><a href="#4、ServiceMethod-lt-gt-loadServiceMethod-Method-method" class="headerlink" title="4、ServiceMethod&lt;?&gt; loadServiceMethod(Method method)"></a>4、ServiceMethod&lt;?&gt; loadServiceMethod(Method method)</h2><p>解析接口当中的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ServiceMethod&lt;?&gt; loadServiceMethod(Method method) &#123;</span><br><span class="line">&#x2F;&#x2F;先看缓存中是否存在，存在直接返回</span><br><span class="line">  ServiceMethod&lt;?&gt; result &#x3D; serviceMethodCache.get(method);</span><br><span class="line">  if (result !&#x3D; null) return result;</span><br><span class="line">  </span><br><span class="line">  synchronized (serviceMethodCache) &#123;</span><br><span class="line">  &#x2F;&#x2F;在多线程情况下，在解析之前再从缓存中获取一次</span><br><span class="line">    result &#x3D; serviceMethodCache.get(method);</span><br><span class="line">    if (result &#x3D;&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F;开始真正的解析</span><br><span class="line">      result &#x3D; ServiceMethod.parseAnnotations(this, method);</span><br><span class="line">      &#x2F;&#x2F;解析完之后将解析之后的结果存到缓存方便下次使用</span><br><span class="line">      serviceMethodCache.put(method, result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5、ServiceMethod-parseAnnotations-："><a href="#5、ServiceMethod-parseAnnotations-：" class="headerlink" title="5、ServiceMethod#parseAnnotations()："></a>5、ServiceMethod#parseAnnotations()：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static &lt;T&gt; ServiceMethod&lt;T&gt; parseAnnotations(Retrofit retrofit, Method method) &#123;</span><br><span class="line">&#x2F;&#x2F;解析接口上的方法的注解</span><br><span class="line">  RequestFactory requestFactory &#x3D; RequestFactory.parseAnnotations(retrofit, method);</span><br><span class="line"></span><br><span class="line">  Type returnType &#x3D; method.getGenericReturnType();</span><br><span class="line">  if (Utils.hasUnresolvableType(returnType)) &#123;</span><br><span class="line">    throw methodError(</span><br><span class="line">        method,</span><br><span class="line">        &quot;Method return type must not include a type variable or wildcard: %s&quot;,</span><br><span class="line">        returnType);</span><br><span class="line">  &#125;</span><br><span class="line">  if (returnType &#x3D;&#x3D; void.class) &#123;</span><br><span class="line">    throw methodError(method, &quot;Service methods cannot return void.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6、RequestFactory-parseAnnotations-："><a href="#6、RequestFactory-parseAnnotations-：" class="headerlink" title="6、RequestFactory#parseAnnotations()："></a>6、RequestFactory#parseAnnotations()：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static RequestFactory parseAnnotations(Retrofit retrofit, Method method) &#123;</span><br><span class="line">&#x2F;&#x2F;这里采用了建造者模式，来构建RequestFactory</span><br><span class="line">  return new Builder(retrofit, method).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7、RequestFactory-parseMethodAnnotation-："><a href="#7、RequestFactory-parseMethodAnnotation-：" class="headerlink" title="7、RequestFactory# parseMethodAnnotation()："></a>7、RequestFactory# parseMethodAnnotation()：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void parseMethodAnnotation(Annotation annotation) &#123;</span><br><span class="line">    &#x2F;&#x2F;省略部分代码....</span><br><span class="line">    &#x2F;&#x2F;这里会解析不同的http的请求方法，这里只对get请求做分析</span><br><span class="line">     else if (annotation instanceof GET) &#123;</span><br><span class="line">       parseHttpMethodAndPath(&quot;GET&quot;, ((GET) annotation).value(), false);</span><br><span class="line">     &#125; </span><br><span class="line">      &#x2F;&#x2F;省略部分代码....</span><br><span class="line">     else if (annotation instanceof HTTP) &#123;</span><br><span class="line">       HTTP http &#x3D; (HTTP) annotation;</span><br><span class="line">       parseHttpMethodAndPath(http.method(), http.path(), http.hasBody());</span><br><span class="line">     &#125; else if (annotation instanceof retrofit2.http.Headers) &#123;</span><br><span class="line">       String[] headersToParse &#x3D; ((retrofit2.http.Headers) annotation).value();</span><br><span class="line">       if (headersToParse.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">         throw methodError(method, &quot;@Headers annotation is empty.&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       headers &#x3D; parseHeaders(headersToParse);</span><br><span class="line">     &#125; else if (annotation instanceof Multipart) &#123;</span><br><span class="line">       if (isFormEncoded) &#123;</span><br><span class="line">         throw methodError(method, &quot;Only one encoding annotation is allowed.&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       isMultipart &#x3D; true;</span><br><span class="line">     &#125; else if (annotation instanceof FormUrlEncoded) &#123;</span><br><span class="line">       if (isMultipart) &#123;</span><br><span class="line">         throw methodError(method, &quot;Only one encoding annotation is allowed.&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       isFormEncoded &#x3D; true;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="8、RequestFactory-parseHttpMethodAndPath"><a href="#8、RequestFactory-parseHttpMethodAndPath" class="headerlink" title="8、RequestFactory#parseHttpMethodAndPath():"></a>8、RequestFactory#parseHttpMethodAndPath():</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void parseHttpMethodAndPath(String httpMethod, String value, boolean hasBody) &#123;</span><br><span class="line">  if (this.httpMethod !&#x3D; null) &#123;</span><br><span class="line">    throw methodError(</span><br><span class="line">        method,</span><br><span class="line">        &quot;Only one HTTP method is allowed. Found: %s and %s.&quot;,</span><br><span class="line">        this.httpMethod,</span><br><span class="line">        httpMethod);</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;将方法进行保存，并记录了是否有请求体</span><br><span class="line">  this.httpMethod &#x3D; httpMethod;</span><br><span class="line">  this.hasBody &#x3D; hasBody;</span><br><span class="line">   &#x2F;&#x2F;如果这个请求方法注解中没有value，直接返回</span><br><span class="line">  if (value.isEmpty()) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 看这个请求方法注解中是否存在?</span><br><span class="line">  int question &#x3D; value.indexOf(&#39;?&#39;);</span><br><span class="line">  if (question !&#x3D; -1 &amp;&amp; question &lt; value.length() - 1) &#123;</span><br><span class="line">    &#x2F;&#x2F; Ensure the query string does not have any named parameters.</span><br><span class="line">    String queryParams &#x3D; value.substring(question + 1);</span><br><span class="line">    Matcher queryParamMatcher &#x3D; PARAM_URL_REGEX.matcher(queryParams);</span><br><span class="line">    if (queryParamMatcher.find()) &#123;</span><br><span class="line">      throw methodError(</span><br><span class="line">          method,</span><br><span class="line">          &quot;URL query string \&quot;%s\&quot; must not have replace block. &quot;</span><br><span class="line">              + &quot;For dynamic query parameters use @Query.&quot;,</span><br><span class="line">          queryParams);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.relativeUrl &#x3D; value;</span><br><span class="line">  &#x2F;&#x2F;解析了注解当中的value当中的参数信息</span><br><span class="line">  this.relativeUrlParamNames &#x3D; parsePathParameters(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9、HttpServiceMethod-parseAnnotations-："><a href="#9、HttpServiceMethod-parseAnnotations-：" class="headerlink" title="9、HttpServiceMethod.parseAnnotations()："></a>9、HttpServiceMethod.parseAnnotations()：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HttpServiceMethod实现了ServiceMethod这个抽象类，里面实现了invoke()，在前面我们就是想要找到这个invoke()是怎么执行的</span><br><span class="line"></span><br><span class="line">final @Nullable ReturnT invoke(Object[] args) &#123;</span><br><span class="line">&#x2F;&#x2F;创建了一个Retrofit的OkHttpCall</span><br><span class="line">    Call&lt;ResponseT&gt; call &#x3D; new OkHttpCall&lt;&gt;(requestFactory, args, callFactory, responseConverter);</span><br><span class="line">    &#x2F;&#x2F;交给了一个adapter，adapter在初始化Retrofit时如果我们没有add过，会有个默认的adapter，用来将执行结果切换到主线程的</span><br><span class="line">    return adapt(call, args);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="10、默认的adapter："><a href="#10、默认的adapter：" class="headerlink" title="10、默认的adapter："></a>10、默认的adapter：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">platform.defaultCallAdapterFactories(callbackExecutor)会传入一个默认的callbackExecutor</span><br><span class="line">    static final class MainThreadExecutor implements Executor &#123;</span><br><span class="line">    &#x2F;&#x2F;创建一个主线程的handler</span><br><span class="line">      private final Handler handler &#x3D; new Handler(Looper.getMainLooper());</span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      public void execute(Runnable r) &#123;</span><br><span class="line">        handler.post(r);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="11、如果没有添加新的adapter"><a href="#11、如果没有添加新的adapter" class="headerlink" title="11、如果没有添加新的adapter"></a>11、如果没有添加新的adapter</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public Type responseType() &#123;</span><br><span class="line">        return responseType;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      public Call&lt;Object&gt; adapt(Call&lt;Object&gt; call) &#123;</span><br><span class="line">      &#x2F;&#x2F;这里会将之前创建的Retrofit的OkHttpCall传进来，并交给Executor执行</span><br><span class="line">        return executor &#x3D;&#x3D; null ? call : new ExecutorCallbackCall&lt;&gt;(executor, call);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>12、当在使用Retrofit时，得到Call时并调用enqueue()时，在没有添加任何新的CallAdapter时，那么得到的就是这个默认的Adapter内部的一个ExecutorCallbackCall：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void enqueue(final Callback&lt;T&gt; callback) &#123;</span><br><span class="line">  Objects.requireNonNull(callback, &quot;callback &#x3D;&#x3D; null&quot;);</span><br><span class="line">   &#x2F;&#x2F;这个delegate就是在前面invoke()方法中创建的Retrofit的OkHttpCall</span><br><span class="line">  delegate.enqueue(</span><br><span class="line">      new Callback&lt;T&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onResponse(Call&lt;T&gt; call, final Response&lt;T&gt; response) &#123;</span><br><span class="line">         </span><br><span class="line">          callbackExecutor.execute(</span><br><span class="line">              () -&gt; &#123;</span><br><span class="line">              &#x2F;&#x2F;将执行结果切换到主线程中去</span><br><span class="line">                if (delegate.isCanceled()) &#123;</span><br><span class="line">                  callback.onFailure(ExecutorCallbackCall.this, new IOException(&quot;Canceled&quot;));</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                  callback.onResponse(ExecutorCallbackCall.this, response);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onFailure(Call&lt;T&gt; call, final Throwable t) &#123;</span><br><span class="line">          callbackExecutor.execute(() -&gt; callback.onFailure(ExecutorCallbackCall.this, t));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>​        retrofit是对OkHttp的进一步封装，里面用到了大量的设计模式进行解耦，内部涉及的设计模式：<br>​            1、Retrofit做为整个项目的门面，用到了门面模式<br>​            2、在配置Adapter或者Convert时用到了工厂方法<br>​            3、在创建Retrofit时用到了建造者模式<br>​            4、在调用create()方法时用到了动态代理<br>​            5、在查找合适的adapter的时候用到了策略模式，通过returnType去查找合适的adapter<br>​            6、通过adapter的adapt()转换时，用到了适配模式<br>​            7、在adapter的adapt()中，会传入一个call，传入的call是原始的call，这里用到了静态代理模式<br>​        我们知道之前在使用okHttp的时候需要配置各种requestBody、请求方法等等信息，这些都是很琐碎的事，retrofit通过大量的注解+反射的方式来帮我们动态的做了这些事<br>​        所以retrofit只是一个对okHttp进一步封装的封装框架，而不是网络框架真正做网络处理的是okHttp</p>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>第三方源码</tag>
      </tags>
  </entry>
  <entry>
    <title>blockcanary1.5源码分析</title>
    <url>/2021/01/13/blockcanary1-5%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="一、基本使用："><a href="#一、基本使用：" class="headerlink" title="一、基本使用："></a>一、基本使用：</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">debugImplementation &#39;com.github.markzhai:blockcanary-android:1.5.0&#39;</span><br></pre></td></tr></table></figure>

<p>在自己的Application的onCreate()中添入下面语句:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BlockCanary.install(this, BlockCanaryContext()).start()</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="二、源码分析："><a href="#二、源码分析：" class="headerlink" title="二、源码分析："></a>二、源码分析：</h1><h2 id="2-1、BlockCanary-install-："><a href="#2-1、BlockCanary-install-：" class="headerlink" title="2.1、BlockCanary.install()："></a>2.1、BlockCanary.install()：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static BlockCanary install(Context context, BlockCanaryContext blockCanaryContext) &#123;</span><br><span class="line">&#x2F;&#x2F;将两个上下文进行了保存</span><br><span class="line">    BlockCanaryContext.init(context, blockCanaryContext);</span><br><span class="line">    setEnabled(context, DisplayActivity.class, BlockCanaryContext.get().displayNotification());</span><br><span class="line">    &#x2F;&#x2F;获取一个单例的BlockCanary</span><br><span class="line">    return get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>install方法内部比较简单，就是将上下文进行了保存，并得到了一个单例的BlockCanary，接下来我们就看下BlockCanary的构造函数</p>
<h2 id="2-2、BlockCanary构造函数："><a href="#2-2、BlockCanary构造函数：" class="headerlink" title="2.2、BlockCanary构造函数："></a>2.2、BlockCanary构造函数：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private BlockCanary() &#123;</span><br><span class="line">&#x2F;&#x2F;得到一个BlockCanaryInternals</span><br><span class="line">    mBlockCanaryCore &#x3D; BlockCanaryInternals.getInstance();</span><br><span class="line">    mBlockCanaryCore.addBlockInterceptor(BlockCanaryContext.get());</span><br><span class="line">    if (!BlockCanaryContext.get().displayNotification()) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    mBlockCanaryCore.addBlockInterceptor(new DisplayService());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3、BlockCanaryInternals构造函数："><a href="#2-3、BlockCanaryInternals构造函数：" class="headerlink" title="2.3、BlockCanaryInternals构造函数："></a>2.3、BlockCanaryInternals构造函数：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public BlockCanaryInternals() &#123;</span><br><span class="line">    &#x2F;&#x2F;获取堆栈信息的采样器</span><br><span class="line">    stackSampler &#x3D; new StackSampler(</span><br><span class="line">            Looper.getMainLooper().getThread(),</span><br><span class="line">            sContext.provideDumpInterval());</span><br><span class="line">    &#x2F;&#x2F;获取cpu信息的采样器</span><br><span class="line">    cpuSampler &#x3D; new CpuSampler(sContext.provideDumpInterval());</span><br><span class="line">    &#x2F;&#x2F;匿名的LooperMonitor，实现了Printer</span><br><span class="line">    setMonitor(new LooperMonitor(new LooperMonitor.BlockListener() &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onBlockEvent(long realTimeStart, long realTimeEnd,</span><br><span class="line">                                 long threadTimeStart, long threadTimeEnd) &#123;</span><br><span class="line">            &#x2F;&#x2F; Get recent thread-stack entries and cpu usage</span><br><span class="line">            ArrayList&lt;String&gt; threadStackEntries &#x3D; stackSampler</span><br><span class="line">                    .getThreadStackEntries(realTimeStart, realTimeEnd);</span><br><span class="line">            if (!threadStackEntries.isEmpty()) &#123;</span><br><span class="line">                BlockInfo blockInfo &#x3D; BlockInfo.newInstance()</span><br><span class="line">                        .setMainThreadTimeCost(realTimeStart, realTimeEnd, threadTimeStart, threadTimeEnd)</span><br><span class="line">                        .setCpuBusyFlag(cpuSampler.isCpuBusy(realTimeStart, realTimeEnd))</span><br><span class="line">                        .setRecentCpuRate(cpuSampler.getCpuRateInfo())</span><br><span class="line">                        .setThreadStackEntries(threadStackEntries)</span><br><span class="line">                        .flushString();</span><br><span class="line">                &#x2F;&#x2F;将采集到的堆栈信息和cpu信息保存到文件中</span><br><span class="line">                LogWriter.save(blockInfo.toString());</span><br><span class="line"></span><br><span class="line">                if (mInterceptorChain.size() !&#x3D; 0) &#123;</span><br><span class="line">                    for (BlockInterceptor interceptor : mInterceptorChain) &#123;</span><br><span class="line">                        interceptor.onBlock(getContext().provideContext(), blockInfo);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, getContext().provideBlockThreshold(), getContext().stopWhenDebugging()));</span><br><span class="line"></span><br><span class="line">    LogWriter.cleanObsolete();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4、start-："><a href="#2-4、start-：" class="headerlink" title="2.4、start()："></a>2.4、start()：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void start() &#123;</span><br><span class="line">    if (!mMonitorStarted) &#123;</span><br><span class="line">        mMonitorStarted &#x3D; true;</span><br><span class="line">        &#x2F;&#x2F;将前面创建出来的实现了Printer接口的monitor给主线程的Looper使用</span><br><span class="line">        Looper.getMainLooper().setMessageLogging(mBlockCanaryCore.monitor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-5、为什么这样配置了就可以了？"><a href="#2-5、为什么这样配置了就可以了？" class="headerlink" title="2.5、为什么这样配置了就可以了？"></a>2.5、为什么这样配置了就可以了？</h2><p>到这里，我们只看到对blockcanary的基本配置，以及给Looper配置了一个Printer，为什么这样就可以完成卡顿的捕获了？这就得从我们的Handler去分析了。我们知道Handler是<br>android整个所有事件驱动者，包括UI上的各种显示等都会通过Handler来进行处理，而Looper是每一个线程都有的且唯一的，本身是通过ThreadLocal来保证了每个线程Looper的唯一性。<br>在主线程中会主动去调用Looper的loop()<br>在Looper.loop()中在所有事件开始之初有这样一段代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final Printer logging &#x3D; me.mLogging;</span><br><span class="line">      if (logging !&#x3D; null) &#123;</span><br><span class="line">          logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +</span><br><span class="line">                  msg.callback + &quot;: &quot; + msg.what);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>这里我们可以看到，在处理事件之前，会先调用Printer的println()，我们前面自定义了一个实现了Printer接口的Monitor，那么就会调用到我们自定义的Monitor的println()<br>在事件处理结束之后还有一段代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (logging !&#x3D; null) &#123;</span><br><span class="line">    logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 也就是说在所有事件处理结束的时候同样也会调用Printer的println()，那么我们要统计是否存在卡断，就可以统计这两次调用这个方法的时间间隔，就可以来判断是否存在卡顿<br>接下来我们继续看Monitor中的println()是如何处理的</p>
<h2 id="2-6、LooperMonitor-println-："><a href="#2-6、LooperMonitor-println-：" class="headerlink" title="2.6、LooperMonitor#println()："></a>2.6、LooperMonitor#println()：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void println(String x) &#123;</span><br><span class="line">&#x2F;&#x2F;如果是debug的就不进行卡顿分析</span><br><span class="line">    if (mStopWhenDebugging &amp;&amp; Debug.isDebuggerConnected()) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;mPrintingStarted是用来标记是否第一次调用了println()</span><br><span class="line">    if (!mPrintingStarted) &#123;&#x2F;&#x2F;一次事件中第一次调用</span><br><span class="line">        mStartTimestamp &#x3D; System.currentTimeMillis();</span><br><span class="line">        mStartThreadTimestamp &#x3D; SystemClock.currentThreadTimeMillis();</span><br><span class="line">        mPrintingStarted &#x3D; true;</span><br><span class="line">        &#x2F;&#x2F;里面收集堆栈信息喝cpu信息</span><br><span class="line">        startDump();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        final long endTime &#x3D; System.currentTimeMillis();</span><br><span class="line">        mPrintingStarted &#x3D; false;</span><br><span class="line">        &#x2F;&#x2F;如果事件开始的时间和事件执行结束的时间大于3s才进行分析</span><br><span class="line">        if (isBlock(endTime)) &#123;</span><br><span class="line">            notifyBlockEvent(endTime);</span><br><span class="line">        &#125;</span><br><span class="line">        stopDump();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-7、LooperMonitor-notifyBlockEvent-："><a href="#2-7、LooperMonitor-notifyBlockEvent-：" class="headerlink" title="2.7、LooperMonitor#notifyBlockEvent()："></a>2.7、LooperMonitor#notifyBlockEvent()：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  如果在主线程中出现了卡顿，才会调用这里</span><br><span class="line">private void notifyBlockEvent(final long endTime) &#123;</span><br><span class="line">    final long startTime &#x3D; mStartTimestamp;</span><br><span class="line">    final long startThreadTime &#x3D; mStartThreadTimestamp;</span><br><span class="line">    final long endThreadTime &#x3D; SystemClock.currentThreadTimeMillis();</span><br><span class="line">    &#x2F;&#x2F;得到一个在子线程运行的Handler</span><br><span class="line">    HandlerThreadFactory.getWriteLogThreadHandler().post(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">        &#x2F;&#x2F;这里会调用到BlockCanaryInternals构造函数当中创建的匿名函数当中</span><br><span class="line">            mBlockListener.onBlockEvent(startTime, endTime, startThreadTime, endThreadTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、总结："><a href="#三、总结：" class="headerlink" title="三、总结："></a>三、总结：</h1><p>​    1、对于blockcanary原理其实还是比较简单的，就是利用了handler在处理事件的开始和结束都会调用Printer的println()，在一次事件的处理过程中判断两次调用的时间间隔<br>​    通过判断这个时间间隔来判断是否存在卡顿。<br>​    2、对于CPU信息的收集，就是对配置文件当中的内容进行了读取操作</p>
]]></content>
      <tags>
        <tag>第三方源码</tag>
      </tags>
  </entry>
  <entry>
    <title>leakcanary2.6源码分析</title>
    <url>/2021/02/13/leakcanary%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="一、leakcanary配置："><a href="#一、leakcanary配置：" class="headerlink" title="一、leakcanary配置："></a>一、leakcanary配置：</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  &#x2F;&#x2F; 只需要在测试阶段使用，所以只配置debug的</span><br><span class="line">  debugImplementation &#39;com.squareup.leakcanary:leakcanary-android:2.6&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="二、源码分析："><a href="#二、源码分析：" class="headerlink" title="二、源码分析："></a>二、源码分析：</h1><p>在2.4以前都需要手动去注册leakcanary，之后就将这个自动注册的功能放在了provider当中，在配置完leakcanary之后可以在jetified-leakcanary-object-watcher-android-2.6/AndroidManifest.xml中可以看到有一个注册的provider AppWatcherInstaller<br>    provider之所以比Application的onCreate()先执行，我们可以从ActivityThread里的H中handleMessage找到答案</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">case BIND_APPLICATION:</span><br><span class="line">         Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;bindApplication&quot;);</span><br><span class="line">         AppBindData data &#x3D; (AppBindData)msg.obj;</span><br><span class="line">         handleBindApplication(data);</span><br><span class="line">         Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">         break;</span><br><span class="line">         </span><br><span class="line">   handleBindApplication():      </span><br><span class="line">   if (!data.restrictedBackupMode) &#123;</span><br><span class="line">        if (!ArrayUtils.isEmpty(data.providers)) &#123;</span><br><span class="line">            installContentProviders(app, data.providers);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   try &#123;</span><br><span class="line">        mInstrumentation.callApplicationOnCreate(app);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h2 id="AppWatcherInstaller-onCreate"><a href="#AppWatcherInstaller-onCreate" class="headerlink" title="AppWatcherInstaller#onCreate():"></a>AppWatcherInstaller#onCreate():</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override fun onCreate(): Boolean &#123;</span><br><span class="line">  val application &#x3D; context!!.applicationContext as Application</span><br><span class="line">  &#x2F;&#x2F;对监听器进行安装</span><br><span class="line">  AppWatcher.manualInstall(application)</span><br><span class="line">  return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AppWatcher-manualInstall-："><a href="#AppWatcher-manualInstall-：" class="headerlink" title="AppWatcher#manualInstall()："></a>AppWatcher#manualInstall()：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@JvmOverloads</span><br><span class="line">    fun manualInstall(</span><br><span class="line">      application: Application,</span><br><span class="line">      retainedDelayMillis: Long &#x3D; TimeUnit.SECONDS.toMillis(5),</span><br><span class="line">      watchersToInstall: List&lt;InstallableWatcher&gt; &#x3D; appDefaultWatchers(application)</span><br><span class="line">    ) &#123;</span><br><span class="line">      &#x2F;&#x2F;省略部分代码...</span><br><span class="line">      watchersToInstall.forEach &#123;</span><br><span class="line">        it.install()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure>

<h2 id="watchersToInstall"><a href="#watchersToInstall" class="headerlink" title="watchersToInstall:"></a>watchersToInstall:</h2><p> 就是一个List<InstallableWatcher>，具体内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ActivityWatcher(application, reachabilityWatcher),</span><br><span class="line">    FragmentAndViewModelWatcher(application, reachabilityWatcher),</span><br><span class="line">    RootViewWatcher(reachabilityWatcher),</span><br><span class="line">    ServiceWatcher(reachabilityWatcher)   </span><br><span class="line">    其实就是leakcanary默认支持的内存泄露检测的组件，我们只看一个Activity的注册：</span><br><span class="line">   ActivityWatcher#install()：</span><br><span class="line">    override fun install() &#123;</span><br><span class="line">       application.registerActivityLifecycleCallbacks(lifecycleCallbacks)</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">       private val lifecycleCallbacks &#x3D;</span><br><span class="line">         object : Application.ActivityLifecycleCallbacks by noOpDelegate() &#123;</span><br><span class="line">           override fun onActivityDestroyed(activity: Activity) &#123;</span><br><span class="line">           &#x2F;&#x2F;当activity执行onDestory()方法时，才会执行</span><br><span class="line">             reachabilityWatcher.expectWeaklyReachable(</span><br><span class="line">               activity, &quot;$&#123;activity::class.java.name&#125; received Activity#onDestroy() callback&quot;</span><br><span class="line">             )</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>

<h2 id="ObjectWatcher-expectWeaklyReachable-："><a href="#ObjectWatcher-expectWeaklyReachable-：" class="headerlink" title="ObjectWatcher#expectWeaklyReachable()："></a>ObjectWatcher#expectWeaklyReachable()：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Synchronized override fun expectWeaklyReachable(</span><br><span class="line">      watchedObject: Any,</span><br><span class="line">      description: String</span><br><span class="line">    ) &#123;</span><br><span class="line">      if (!isEnabled()) &#123;</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F;先将弱引用队列清空</span><br><span class="line">      removeWeaklyReachableObjects()</span><br><span class="line">      val key &#x3D; UUID.randomUUID()</span><br><span class="line">        .toString()</span><br><span class="line">      val watchUptimeMillis &#x3D; clock.uptimeMillis()</span><br><span class="line">      &#x2F;&#x2F;生成一个新的弱引用对象</span><br><span class="line">      val reference &#x3D;</span><br><span class="line">        KeyedWeakReference(watchedObject, key, description, watchUptimeMillis, queue)</span><br><span class="line">        &#x2F;&#x2F;将新的弱引用保存在map当中</span><br><span class="line">      watchedObjects[key] &#x3D; reference</span><br><span class="line">      checkRetainedExecutor.execute &#123;</span><br><span class="line">      &#x2F;&#x2F;移动需要保留的key</span><br><span class="line">        moveToRetained(key)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     @Synchronized private fun moveToRetained(key: String) &#123;</span><br><span class="line">     &#x2F;&#x2F;再清除了一次弱引用队列，如果map当中还存在，则这些就是内存泄漏得</span><br><span class="line">        removeWeaklyReachableObjects()</span><br><span class="line">        val retainedRef &#x3D; watchedObjects[key]</span><br><span class="line">        if (retainedRef !&#x3D; null) &#123;</span><br><span class="line">          retainedRef.retainedUptimeMillis &#x3D; clock.uptimeMillis()</span><br><span class="line">          &#x2F;&#x2F;对泄漏对象进行分析</span><br><span class="line">          onObjectRetainedListeners.forEach &#123; it.onObjectRetained() &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">       private fun removeWeaklyReachableObjects() &#123;</span><br><span class="line">      </span><br><span class="line">         var ref: KeyedWeakReference?</span><br><span class="line">         do &#123;</span><br><span class="line">         &#x2F;&#x2F;如果弱引用队列中存在，则将这个从map集合中移除掉，剩下的是可能存在泄漏风险的</span><br><span class="line">           ref &#x3D; queue.poll() as KeyedWeakReference?</span><br><span class="line">           if (ref !&#x3D; null) &#123;</span><br><span class="line">             watchedObjects.remove(ref.key)</span><br><span class="line">           &#125;</span><br><span class="line">         &#125; while (ref !&#x3D; null)</span><br><span class="line">       &#125;</span><br><span class="line">      </span><br></pre></td></tr></table></figure>

<h2 id="HeapDumpTrigger-checkRetainedObjects-："><a href="#HeapDumpTrigger-checkRetainedObjects-：" class="headerlink" title="HeapDumpTrigger#checkRetainedObjects()："></a>HeapDumpTrigger#checkRetainedObjects()：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private fun checkRetainedObjects() &#123;</span><br><span class="line">        &#x2F;&#x2F;省略部分代码...</span><br><span class="line">          var retainedReferenceCount &#x3D; objectWatcher.retainedObjectCount</span><br><span class="line">      </span><br><span class="line">          if (retainedReferenceCount &gt; 0) &#123;</span><br><span class="line">          &#x2F;&#x2F; 可能存在被观察的引用将要变得弱可达，但是还未入队引用队列。</span><br><span class="line">          &#x2F;&#x2F; 这时候应该主动调用一次 GC，可以避免一次 heap dump</span><br><span class="line">            gcTrigger.runGc()</span><br><span class="line">            retainedReferenceCount &#x3D; objectWatcher.retainedObjectCount</span><br><span class="line">          &#125;</span><br><span class="line">      </span><br><span class="line">          &#x2F;&#x2F;校验当前泄漏实例个数，最多不能超过5个，超过5个将不再进行dump</span><br><span class="line">          if (checkRetainedCount(retainedReferenceCount, config.retainedVisibleThreshold)) return</span><br><span class="line">      </span><br><span class="line">          val now &#x3D; SystemClock.uptimeMillis()</span><br><span class="line">          val elapsedSinceLastDumpMillis &#x3D; now - lastHeapDumpUptimeMillis</span><br><span class="line">          &#x2F;&#x2F;上一次dump的时间间隔如果小于60s，就延迟再执行这个dump</span><br><span class="line">          if (elapsedSinceLastDumpMillis &lt; WAIT_BETWEEN_HEAP_DUMPS_MILLIS) &#123;</span><br><span class="line">            onRetainInstanceListener.onEvent(DumpHappenedRecently)</span><br><span class="line">            showRetainedCountNotification(</span><br><span class="line">              objectCount &#x3D; retainedReferenceCount,</span><br><span class="line">              contentText &#x3D; application.getString(R.string.leak_canary_notification_retained_dump_wait)</span><br><span class="line">            )</span><br><span class="line">            scheduleRetainedObjectCheck(</span><br><span class="line">              delayMillis &#x3D; WAIT_BETWEEN_HEAP_DUMPS_MILLIS - elapsedSinceLastDumpMillis</span><br><span class="line">            )</span><br><span class="line">            return</span><br><span class="line">          &#125;</span><br><span class="line">      </span><br><span class="line">          dismissRetainedCountNotification()</span><br><span class="line">          val visibility &#x3D; if (applicationVisible) &quot;visible&quot; else &quot;not visible&quot;</span><br><span class="line"> </span><br><span class="line">          dumpHeap(</span><br><span class="line">            retainedReferenceCount &#x3D; retainedReferenceCount,</span><br><span class="line">            retry &#x3D; true,</span><br><span class="line">            reason &#x3D; &quot;$retainedReferenceCount retained objects, app is $visibility&quot;</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="GcTrigger-runGc-："><a href="#GcTrigger-runGc-：" class="headerlink" title="GcTrigger#runGc()："></a>GcTrigger#runGc()：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun runGc() &#123;</span><br><span class="line">           &#x2F;&#x2F;System.gc()内部也调用了Runtime().gc()，但在调用前做了处理，System.gc()在执行了一次之后不会再执行，所以这里使用Runtime.gc()</span><br><span class="line">            Runtime.getRuntime()</span><br><span class="line">              .gc()</span><br><span class="line">            enqueueReferences()</span><br><span class="line">            System.runFinalization()</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          </span><br><span class="line">      private fun dumpHeap(</span><br><span class="line">          retainedReferenceCount: Int,</span><br><span class="line">          retry: Boolean,</span><br><span class="line">          reason: String</span><br><span class="line">        ) &#123;</span><br><span class="line">          saveResourceIdNamesToMemory()</span><br><span class="line">          val heapDumpUptimeMillis &#x3D; SystemClock.uptimeMillis()</span><br><span class="line">          KeyedWeakReference.heapDumpUptimeMillis &#x3D; heapDumpUptimeMillis</span><br><span class="line">          when (val heapDumpResult &#x3D; heapDumper.dumpHeap()) &#123;</span><br><span class="line">           &#x2F;&#x2F;省略部分代码...</span><br><span class="line">            is HeapDump -&gt; &#123;</span><br><span class="line">              lastDisplayedRetainedObjectCount &#x3D; 0</span><br><span class="line">              lastHeapDumpUptimeMillis &#x3D; SystemClock.uptimeMillis()</span><br><span class="line">              &#x2F;&#x2F;先将这个引用从map中移除</span><br><span class="line">              objectWatcher.clearObjectsWatchedBefore(heapDumpUptimeMillis)</span><br><span class="line">              &#x2F;&#x2F;启动了一个前台的服务，进行真正内存分析操作，以前Square用的是haha的分析库，后来换成了一个全新的分析库shark，官方说这个库比之前的库快了6倍而且减少了90%的内存消耗</span><br><span class="line">              </span><br><span class="line">              HeapAnalyzerService.runAnalysis(</span><br><span class="line">                context &#x3D; application,</span><br><span class="line">                heapDumpFile &#x3D; heapDumpResult.file,</span><br><span class="line">                heapDumpDurationMillis &#x3D; heapDumpResult.durationMillis,</span><br><span class="line">                heapDumpReason &#x3D; reason</span><br><span class="line">              )</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">      对于这个库如何去分析的内存泄漏，就不再进行深究。</span><br></pre></td></tr></table></figure>

<h1 id="三、总结："><a href="#三、总结：" class="headerlink" title="三、总结："></a>三、总结：</h1><p>​    1、在Leakcanary的源码当中，我们学到了第三方库的初始化可以放到ContentProvider当中，就不需要我们再在Application当中去初始化<br>​    2、当引用发生回收时，会将这个引用添加到队列当中<br>​    3、在触发gc时通过Runtime.gc()去触发，并不是通过System.gc()触发，因为System.gc()可能只触发一次就不再触发<br>​    4、当进行dump的过程中，分析内存的时间间隔为60s，在没达到60s时会进行顺延<br>​    5、当泄漏实例超过5个，将不再进行dump操作<br>​    6、在进行内存分析的过程中，之前是用的haha的库，后面用了shark进行分析，且按照官方所说，shark的内存消耗降低了90%，速度快了6倍</p>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>第三方源码</tag>
      </tags>
  </entry>
  <entry>
    <title>深入RecyclerView</title>
    <url>/2021/03/24/%E6%B7%B1%E5%85%A5RecyclerView/</url>
    <content><![CDATA[<h1 id="一、ListView与RecyclerView区别："><a href="#一、ListView与RecyclerView区别：" class="headerlink" title="一、ListView与RecyclerView区别："></a>一、ListView与RecyclerView区别：</h1><p>​    1.1、在ListView的Adapter中在getView()中会有大量的代码，而在RecyclerView的Adapter当中将原本的getView()通过onCreateViewHolder()和onBindViewHolder()<br>​        进行了分离。<br>​    1.2、ListView回收复用的是View，而RecyclerView回收复用的是ViewHolder<br>​    1.3、在ListView的Adapter的ViewType通常是返回的连续的，是因为ListView当中使用缓存是通过RecycleBin来实现的，在这个当中存在两个数组：</p>
<a id="more"></a>

<p>​        View[] mActiveViews：是显示在屏幕当中的View<br>​        ArrayList<View>[] mScrapViews：被废弃的View<br>​        正因为在ListView当中是通过这两个数组来实现的缓存，所以ViewType需要返回的是一个连续的数字<br>​    1.4、为什么有了ListView还要重新搞出一个RecyclerView呢？<br>​        在ListView当中如果要给一个item做动画是很难的，原因在于不知道具体哪个或者哪几个item发生了改变，每次修改完之后都需要全部重新测量、布局等操作，换句话说<br>​        在ListView上面做局部刷新很难。所以促使了RecyclerView的产生。</p>
<h1 id="二、RecyclerView的几大核心组件："><a href="#二、RecyclerView的几大核心组件：" class="headerlink" title="二、RecyclerView的几大核心组件："></a>二、RecyclerView的几大核心组件：</h1><p>​    极致的体现了单一职责的设计</p>
<h2 id="2-1、LayoutManager："><a href="#2-1、LayoutManager：" class="headerlink" title="2.1、LayoutManager："></a>2.1、LayoutManager：</h2><p>​        LayoutManager用来管理RecyclerView的onMeasure和onLayout，在RecyclerView的onMeasure当中可以看到下面一段代码<br>​        //这里的mLayout就是LayoutManager<br>​         mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec)<br>​         在RecyclerView的onLayout()中的dispatchLayout()中会去调用<br>​         dispatchLayoutStep1();<br>​         mLayout.setExactMeasureSpecsFrom(this);<br>​         dispatchLayoutStep2();<br>​         在dispatchLayoutStep2()中会去调用<br>​         mLayout.onLayoutChildren(mRecycler, mState)，所以LayoutManager是来管理RecyclerView的测量和布局的<br>​         LayoutManager只会向Recycler要View</p>
<h2 id="2-2、Recycler："><a href="#2-2、Recycler：" class="headerlink" title="2.2、Recycler："></a>2.2、Recycler：</h2><p>​         作为缓存管理，缓存管理找到相应的ViewHolder，如果最开始时是空的，那么Recycler就会去调用adapter的onCreateViewHolder(),最终是得到的ViewHolder</p>
<h2 id="2-3、Adapter："><a href="#2-3、Adapter：" class="headerlink" title="2.3、Adapter："></a>2.3、Adapter：</h2><p>​         Adapter只是将数据和视图进行绑定的</p>
<h2 id="2-4、ItemDecoration："><a href="#2-4、ItemDecoration：" class="headerlink" title="2.4、ItemDecoration："></a>2.4、ItemDecoration：</h2><p>​    </p>
<h1 id="三、ListView和RecyclerView复用机制对比及RecyclerView缓存机制："><a href="#三、ListView和RecyclerView复用机制对比及RecyclerView缓存机制：" class="headerlink" title="三、ListView和RecyclerView复用机制对比及RecyclerView缓存机制："></a>三、ListView和RecyclerView复用机制对比及RecyclerView缓存机制：</h1><h2 id="3-1、ListView的二级缓存机制："><a href="#3-1、ListView的二级缓存机制：" class="headerlink" title="3.1、ListView的二级缓存机制："></a>3.1、ListView的二级缓存机制：</h2><p>​        ListView当中的复用机制，是通过RecycleBin实现的<br>​        //只有当通过非notifyDataSetChange(),例如：requestLayout()等其他手段来更新界面时，这个数组才有用，界面数据没有发生变化，直接通过从这个数组当中取出View来复用。这一层的缓存<br>​        //使用到几率比较低，<br>​        private View[] mActiveViews = new View[0];<br>​        //当在滑动时或者notifyDataSetChange()时都会用到，当在滑动过程当中，如果这个item滑动出了屏幕，那么就会将这个view放到这个mScrapViews，进入屏幕时<br>​        //就会从mScrapViews中拿出一个类型相同的View来进行复用，如果在回收池中没有这种类型的View，那么就会在getView()当中创建一个View出来。<br>​         private ArrayList<View>[] mScrapViews;<br>​       ListView的复用逻辑，首先会现在mActiveViews当中去找，如果找不到则通过ViewType在mScrapViews当中去找，如果再找不到，则重新创建一个新的View</p>
<h2 id="3-2、RecyclerView的复用机制：按先后顺序"><a href="#3-2、RecyclerView的复用机制：按先后顺序" class="headerlink" title="3.2、RecyclerView的复用机制：按先后顺序"></a>3.2、RecyclerView的复用机制：按先后顺序</h2><p>​        mAttachedScrap：暂存区<br>​            如果调用notifyItemChanged、notifyItemInserted()或者notifyItemRemoved()在一次布局中会将没有发生改变的item存放到mAttachedScrap，当某个<br>​            ViewHolder发生了改变，会将这个ViewHolder也放入另外一个暂存区mChangedScrap<br>​        mCachedViews：<br>​             在RecyclerView的内部有一个类Recycler跟ListView当中的RecycleBin作用一样都是进行复用的<br>​             //这个mCachedViews就相当于RecycleBin当中的mActiveViews，但是mActiveViews作用的场景很有限，只在数据没发生改变触发了onLayout时才会发挥作用，<br>​             //mCachedViews则是提升了在滑动过程当中重新绑定的数据的操作，默认是存放两个缓存的View，可以通过setItemViewCacheSize()来改变这个默认的缓存大小<br>​             ArrayList<ViewHolder> mCachedViews = new ArrayList<ViewHolder>()<br>​             //当RecyclerView在滑动过程中，当向上移动item移出屏幕时，就会存放到mCachedViews，当再次向下移动时，会先根据position从这个缓存当中去找，如果在<br>​             //这个缓存中找到了对应position的ViewHolder，那么就直接进行复用,mCachedViews是不会按照ViewType来区分的。<br>​             如何来判断一个View被回收又重新回到了屏幕上，可以通过下面的两个方法来判断：<br>​             public void onViewAttachedToWindow(VH holder) {<br>​                     }<br>​              public void onViewDetachedFromWindow(VH holder) {<br>​              }<br>​             当mCachedViews当中已经存放满了，仍然在继续滑动，那么新的item的将会被放进mCachedViews中，最先进入的将会被存放到回收池RecycledViewPool中，如果回滑<br>​             的时候会先从mCachedViews当中拿出ViewHolder来复用，再进行回滑时，会根据ViewType从RecycledViewPool中拿到ViewHolder来复用<br>​        RecycledViewPool：<br>​              RecycledViewPool当中有个静态变量DEFAULT_MAX_SCRAP = 5，表示每个ViewType类型的ViewHolder只能最多存放5个，可以通过setMaxRecycledViews()来<br>​              设置某种类型的ViewHolder的最大存放数，使用场景：如果在屏幕上相同类型的Item存在很多，超过5个，那么就可以重新设置这个最大值，复用的时候就会有更多的<br>​              参与缓存。可以多个RecyclerView设置同一个RecycledViewPool<br>​              当调用notifyDataSetChange()时，是不会进入mCachedViews的缓存的，因为mCachedViews当中缓存的ViewHolder是不会重新进行数据绑定的，会直接进入<br>​              RecycledViewPool，如果一屏的数据多余5个，那么在这个时候只有5个可以从缓存中拿到进行复用，其他的都需要进行onCreateViewHolder()和onBindViewHolder()<br>​               就造成大量的内存消耗，那么我们可以在notifyDataSetChange()之前把RecycledViewPool的默认容量调大，调用完之后再将回收池容量调小，但是这样很不优雅。<br>​               在实际的开发中，我们不能一股脑儿的直接notifyDataSetChange()来更新数据，因为这样会将所有的 全部回收，再更新数据。所以我们最好局部刷新。<br>​               如果实际开发中直接notifyDataSetChange()是非常愚蠢的，这样会导致所有的item重新onBindViewHolder，如果只调用notifyItemChanged()只有指定这个位置的ViewHolder才会<br>​               重新调用onBindViewHolder()</p>
<h2 id="3-3、RecyclerView当中的pre-post-layout："><a href="#3-3、RecyclerView当中的pre-post-layout：" class="headerlink" title="3.3、RecyclerView当中的pre/post-layout："></a>3.3、RecyclerView当中的pre/post-layout：</h2><p>​               当在notifyItemRemoved()、notifyItemInsert()时都有动画，做动画时需要知道起始位置和结束位置，在RecyclerView当中如果调用notifyItemRemoved()<br>​               就通过pre-layout来计算当前位置的下一个的起始位置，post-layout来计算结束位置，这样就知道了怎么去做这个动画了。而在做动画时其实就是一个ViewHolder在做<br>​               离场动画，另外一个ViewHolder在做进场动画，所以pre-layout会在暂存区mAttachedScrap、mChangedScrap中去获取ViewHolder ，而post-layout只会在mAttachedScrap<br>​               中去获取ViewHolder。所以在item更新时会出现图片闪烁问题，原因就在于会有两个ViewHolder在做动画，可以通过setSupportsChangeAnimations(false)来禁止切换动画，那么<br>​               在pre-layout时就会使用同一个ViewHolder，但是这样会将插入和删除的动画都弄没了，所以我们需要使用另外一种方案：在更新时我们只需要使用双参数的notifyItemChanged(,”payload”)<br>​               payload：翻译为”有效合载”，即真正的核心数据，例如：在http过程中即使发送一个字符串，也需要发送大量的head，这个payload的意思就是只发送这个改变的数据，而其他head不变。</p>
<h2 id="3-4、RecyclerView回收机制："><a href="#3-4、RecyclerView回收机制：" class="headerlink" title="3.4、RecyclerView回收机制："></a>3.4、RecyclerView回收机制：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tryGetViewHolderForPositionByDeadline()返回一个ViewHolder:</span><br><span class="line">&#x2F;&#x2F; 0) If there is a changed scrap, try to find from there</span><br><span class="line">&#x2F;&#x2F;只有当是preLayout时才会到changeScrap当中去找</span><br><span class="line"> if (mState.isPreLayout()) &#123;</span><br><span class="line">     holder &#x3D; getChangedScrapViewForPosition(position);</span><br><span class="line">     fromScrapOrHiddenOrCache &#x3D; holder !&#x3D; null;</span><br><span class="line"> &#125;</span><br><span class="line"> &#x2F;&#x2F; 1) Find by position from scrap&#x2F;hidden list&#x2F;cache</span><br><span class="line">   if (holder &#x3D;&#x3D; null) &#123;</span><br><span class="line">   &#x2F;&#x2F;从Scrap、cache中去查找，hidden则是当一个item被新插入的item挤出屏幕，新增的item又立马被移除了，那么被挤出的item又要回来，所以hidden</span><br><span class="line">   &#x2F;&#x2F;就起到这样的作用getScrapOrHiddenOrCachedHolderForPosition在pre-layout和post-layout时都会执行</span><br><span class="line">       holder &#x3D; getScrapOrHiddenOrCachedHolderForPosition(position, dryRun);</span><br><span class="line">   在方法内部可以看到只要是pre-layout不管holder有没有被remove都会命中，如果没有找到，那么就会从hidden当中去找。</span><br><span class="line">   在前面都没找到，那么就会从第一层缓存当中去查找，对于RecyclerView的设计者来说，mCachedViews才是第一层缓存</span><br><span class="line">    &#x2F;&#x2F; Search in our first-level recycled view cache.</span><br><span class="line">               final int cacheSize &#x3D; mCachedViews.size();</span><br><span class="line">               for (int i &#x3D; 0; i &lt; cacheSize; i++) &#123;</span><br><span class="line">                   final ViewHolder holder &#x3D; mCachedViews.get(i);</span><br><span class="line">                   &#x2F;&#x2F; invalid view holders may be in cache if adapter has stable ids as they can be</span><br><span class="line">                   &#x2F;&#x2F; retrieved via getScrapOrCachedViewForId</span><br><span class="line">                   &#x2F;&#x2F;通过position去查找得到的ViewHolder是不需要重新进行数据绑定的</span><br><span class="line">                   if (!holder.isInvalid() &amp;&amp; holder.getLayoutPosition() &#x3D;&#x3D; position) &#123;&#125;</span><br><span class="line">  &#x2F;&#x2F;当在前面通过position没有找到，那么会根据ViewType继续去回收池中查找，                 </span><br><span class="line">  final int type &#x3D; mAdapter.getItemViewType(offsetPosition);</span><br><span class="line">&#x2F;&#x2F; 2) Find from scrap&#x2F;cache via stable ids, if exists</span><br><span class="line">&#x2F;&#x2F;在从回收池中查找之前会先看adapter是否设置过setHasStableIds(),这个只在调用notifyDataSetChange时才有意义，因为在</span><br><span class="line">&#x2F;&#x2F;调用notifyDataSetChange开始布局时，并不会像局部刷新一样放入Scrap当中，而是全部被放到回收池中，如果整个屏幕上有10个同</span><br><span class="line">&#x2F;&#x2F;类型的item，但回收池中只有5个，那么多余的就会重新去创建。通过设置StableIds和getItemId()那么所有的数据就会进入到Scrap当中，而不会进入到</span><br><span class="line">&#x2F;&#x2F;回收池，而且也会存在动画</span><br><span class="line">if (mAdapter.hasStableIds()) &#123;</span><br><span class="line">    holder &#x3D; getScrapOrCachedViewForId(mAdapter.getItemId(offsetPosition),</span><br><span class="line">            type, dryRun);</span><br><span class="line">    if (holder !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; update position</span><br><span class="line">        holder.mPosition &#x3D; offsetPosition;</span><br><span class="line">        fromScrapOrHiddenOrCache &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">3)、在前面仍然没有找到合适的ViewHolder，就到回收池中去查找</span><br><span class="line"> if (holder &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; fallback to pool</span><br><span class="line">                    holder &#x3D; getRecycledViewPool().getRecycledView(type);</span><br><span class="line">                    if (holder !&#x3D; null) &#123;</span><br><span class="line">                        holder.resetInternal();</span><br><span class="line">                        if (FORCE_INVALIDATE_DISPLAY_LIST) &#123;</span><br><span class="line">                            invalidateDisplayListInt(holder);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;                </span><br><span class="line"> 4)、在缓存当中没有找到缓存的ViewHolder，就只能去调用onCreateViewHolder()来创建一个ViewHolder</span><br><span class="line"> 5)、ViewHolder的数据是否需要重新绑定</span><br><span class="line">  if (mState.isPreLayout() &amp;&amp; holder.isBound()) &#123;</span><br><span class="line">                 &#x2F;&#x2F; do not update unless we absolutely have to.</span><br><span class="line">                 holder.mPreLayoutPosition &#x3D; position;</span><br><span class="line">             &#125; else if (!holder.isBound() || holder.needsUpdate() || holder.isInvalid()) &#123;</span><br><span class="line">                 final int offsetPosition &#x3D; mAdapterHelper.findPositionOffset(position);</span><br><span class="line">                  &#x2F;&#x2F;如果拿到的ViewHolder需要重新绑定数据，就会去调用adapter.onBindViewHolder</span><br><span class="line">                 bound &#x3D; tryBindViewHolderByDeadline(holder, offsetPosition, position, deadlineNs);</span><br><span class="line">             &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Android源码</tag>
      </tags>
  </entry>
  <entry>
    <title>OkHttp源码分析</title>
    <url>/2020/03/29/OkHttp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="一、OkHttp发展史："><a href="#一、OkHttp发展史：" class="headerlink" title="一、OkHttp发展史："></a>一、OkHttp发展史：</h1><p>​    OkHttp作为现在Android开发过程中用得最多的网络访问框架，在早期使用了Google的HttpUrlConnection实现，后来square<br>公司将HttpUrlConnection废弃掉，直接自己写了一套对http报文发送和解析的socket。</p>
<a id="more"></a>

<h1 id="二、请求流程分析："><a href="#二、请求流程分析：" class="headerlink" title="二、请求流程分析："></a>二、请求流程分析：</h1><h2 id="2-1、基本使用："><a href="#2-1、基本使用：" class="headerlink" title="2.1、基本使用："></a>2.1、基本使用：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class OkHttpMainActivity : Activity() &#123;</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        &#x2F;&#x2F;1、创建OkHttpClient</span><br><span class="line">        val client:OkHttpClient &#x3D; OkHttpClient()</span><br><span class="line">        &#x2F;&#x2F;2、构建请求,包括：请求域名、请求方法、header等等</span><br><span class="line">        val request &#x3D; Request.Builder().url(&quot;&quot;).method(&quot;GET&quot;, null).build()</span><br><span class="line">        &#x2F;&#x2F;3、异步执行，会添加到队列，并在线程池中执行</span><br><span class="line">        client.newCall(request).enqueue(object:Callback&#123;</span><br><span class="line">            override fun onFailure(call: Call, e: IOException) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            override fun onResponse(call: Call, response: Response) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">        &#x2F;&#x2F;4、同步请求,不会将请求放入子线程,所以需要我们主动放到子线程中去执行</span><br><span class="line">        val response &#x3D; client.newCall(request).execute()</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-2、OkHttp大致框架角色："><a href="#2-2、OkHttp大致框架角色：" class="headerlink" title="2.2、OkHttp大致框架角色："></a>2.2、OkHttp大致框架角色：</h2><p>​    OkHttpClient：<br>​        是对client的配置：Dispatcher、ConnectionPool、Interceptor、followRedirects(是否允许重定向)、followSslRedirects(允许重定向的时候如果发生协议的切换是否允许重定向)<br>​        Dns、Proxy、x509TrustManager(证书校验)、HostnameVerifier。<br>​        对于证书校验是针对于https的，https在建立连接时，服务端会将证书返回给客户端，客户端会对这个证书的真实性进行校验，而在OkHttp当中系统默认提供了对Https的证书校验<br>​        ，所以并不需要我们手动再去验证证书的真实性。<br>​    Call：<br>​        是对访问的抽象，真正做事的是RealCall<br>​    Dispatcher：<br>​        对发起的call做统一处理，例如异步请求，会将请求放进请求队列当中，并将call放入线程池当中去执行</p>
<h2 id="2-3、请求流程源码分析："><a href="#2-3、请求流程源码分析：" class="headerlink" title="2.3、请求流程源码分析："></a>2.3、请求流程源码分析：</h2><h3 id="2-3-1、异步请求enqueue："><a href="#2-3-1、异步请求enqueue：" class="headerlink" title="2.3.1、异步请求enqueue："></a>2.3.1、异步请求enqueue：</h3><h4 id="RealCall-enqueue"><a href="#RealCall-enqueue" class="headerlink" title="RealCall#enqueue():"></a>RealCall#enqueue():</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override fun enqueue(responseCallback: Callback) &#123;</span><br><span class="line">  synchronized(this) &#123;</span><br><span class="line">    check(!executed) &#123; &quot;Already Executed&quot; &#125;</span><br><span class="line">    executed &#x3D; true</span><br><span class="line">  &#125;</span><br><span class="line">  callStart()</span><br><span class="line">  &#x2F;&#x2F;新建一个Call</span><br><span class="line">  client.dispatcher.enqueue(AsyncCall(responseCallback))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Dispatcher-enqueue"><a href="#Dispatcher-enqueue" class="headerlink" title="Dispatcher#enqueue():"></a>Dispatcher#enqueue():</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">internal fun enqueue(call: AsyncCall) &#123;</span><br><span class="line">  synchronized(this) &#123;</span><br><span class="line">  &#x2F;&#x2F;双端队列，先将新创建的call添加进准备队列中</span><br><span class="line">    readyAsyncCalls.add(call)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Mutate the AsyncCall so that it shares the AtomicInteger of an existing running call to</span><br><span class="line">    &#x2F;&#x2F; the same host.</span><br><span class="line">    if (!call.call.forWebSocket) &#123;</span><br><span class="line">    &#x2F;&#x2F;如果不是webSocket，看队列中是否存在host相同的call</span><br><span class="line">      val existingCall &#x3D; findExistingCallWithHost(call.host)</span><br><span class="line">      if (existingCall !&#x3D; null) call.reuseCallsPerHostFrom(existingCall)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  promoteAndExecute()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Dispatcher-promoteAndExecute"><a href="#Dispatcher-promoteAndExecute" class="headerlink" title="Dispatcher#promoteAndExecute():"></a>Dispatcher#promoteAndExecute():</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private fun promoteAndExecute(): Boolean &#123;</span><br><span class="line"> &#x2F;&#x2F;省略部分代码...</span><br><span class="line">  val executableCalls &#x3D; mutableListOf&lt;AsyncCall&gt;()</span><br><span class="line">  val isRunning: Boolean</span><br><span class="line">  synchronized(this) &#123;</span><br><span class="line">  &#x2F;&#x2F;遍历整个ready的队列</span><br><span class="line">    val i &#x3D; readyAsyncCalls.iterator()</span><br><span class="line">    while (i.hasNext()) &#123;</span><br><span class="line">      val asyncCall &#x3D; i.next()</span><br><span class="line">      &#x2F;&#x2F;看正在运行的call有没有超过64</span><br><span class="line">      if (runningAsyncCalls.size &gt;&#x3D; this.maxRequests) break &#x2F;&#x2F; Max capacity.  这个最大请求默认时64，可以自己设置</span><br><span class="line">      if (asyncCall.callsPerHost.get() &gt;&#x3D; this.maxRequestsPerHost) continue &#x2F;&#x2F; 同一个主机的最大请求不能超过5个，同样也是可修改的</span><br><span class="line">      &#x2F;&#x2F;如果前面两个条件都满足，将这个call从ready队列中移除</span><br><span class="line">      i.remove()</span><br><span class="line">      &#x2F;&#x2F;将同一个主机的请求数+1</span><br><span class="line">      asyncCall.callsPerHost.incrementAndGet()</span><br><span class="line">      &#x2F;&#x2F;将这个call添加到可执行的集合中</span><br><span class="line">      executableCalls.add(asyncCall)</span><br><span class="line">      &#x2F;&#x2F;将这个call添加到正在运行的队列中</span><br><span class="line">      runningAsyncCalls.add(asyncCall)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;如果这个正在运行的队列中的数量大于0，则将这个标记为正在运行</span><br><span class="line">    isRunning &#x3D; runningCallsCount() &gt; 0</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;对整个可执行的call进行遍历执行</span><br><span class="line">  for (i in 0 until executableCalls.size) &#123;</span><br><span class="line">    val asyncCall &#x3D; executableCalls[i]</span><br><span class="line">    &#x2F;&#x2F;将这个call任务添加到线程池中执行</span><br><span class="line">    asyncCall.executeOn(executorService)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return isRunning</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RealCall-executeOn"><a href="#RealCall-executeOn" class="headerlink" title="RealCall#executeOn:"></a>RealCall#executeOn:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun executeOn(executorService: ExecutorService) &#123;</span><br><span class="line">  var success &#x3D; false</span><br><span class="line">  try &#123;</span><br><span class="line">  &#x2F;&#x2F;将任务真正的提交到线程池，执行AsyncCall的run方法，AsyncCall实现了Runnable接口</span><br><span class="line">    executorService.execute(this)</span><br><span class="line">    success &#x3D; true</span><br><span class="line">  &#125; catch (e: RejectedExecutionException) &#123;</span><br><span class="line">    val ioException &#x3D; InterruptedIOException(&quot;executor rejected&quot;)</span><br><span class="line">    ioException.initCause(e)</span><br><span class="line">    noMoreExchanges(ioException)</span><br><span class="line">    responseCallback.onFailure(this@RealCall, ioException)</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    if (!success) &#123;</span><br><span class="line">      client.dispatcher.finished(this) &#x2F;&#x2F; This call is no longer running!</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AsyncCall-run"><a href="#AsyncCall-run" class="headerlink" title="AsyncCall#run():"></a>AsyncCall#run():</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override fun run() &#123;</span><br><span class="line">      threadName(&quot;OkHttp $&#123;redactedUrl()&#125;&quot;) &#123;</span><br><span class="line">        var signalledCallback &#x3D; false</span><br><span class="line">        timeout.enter()</span><br><span class="line">        try &#123;</span><br><span class="line">         &#x2F;&#x2F;通过下面的拿到一个请求的response</span><br><span class="line">          val response &#x3D; getResponseWithInterceptorChain()</span><br><span class="line">          signalledCallback &#x3D; true</span><br><span class="line">          &#x2F;&#x2F;将请求结果回调给我们传入的callBack</span><br><span class="line">          responseCallback.onResponse(this@RealCall, response)</span><br><span class="line">        &#125; catch (e: IOException) &#123;</span><br><span class="line">          if (signalledCallback) &#123;</span><br><span class="line">            &#x2F;&#x2F; Do not signal the callback twice!</span><br><span class="line">            Platform.get().log(&quot;Callback failure for $&#123;toLoggableString()&#125;&quot;, Platform.INFO, e)</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            responseCallback.onFailure(this@RealCall, e)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; catch (t: Throwable) &#123;</span><br><span class="line">          cancel()</span><br><span class="line">          if (!signalledCallback) &#123;</span><br><span class="line">            val canceledException &#x3D; IOException(&quot;canceled due to $t&quot;)</span><br><span class="line">            canceledException.addSuppressed(t)</span><br><span class="line">            responseCallback.onFailure(this@RealCall, canceledException)</span><br><span class="line">          &#125;</span><br><span class="line">          throw t</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">        &#x2F;&#x2F;不过请求成功还是失败，都将调用Dispatcher的finished方法</span><br><span class="line">          client.dispatcher.finished(this)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Dispatcher-finished"><a href="#Dispatcher-finished" class="headerlink" title="Dispatcher#finished():"></a>Dispatcher#finished():</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">internal fun finished(call: AsyncCall) &#123;</span><br><span class="line">&#x2F;&#x2F;将当前主机请求数-1</span><br><span class="line">  call.callsPerHost.decrementAndGet()</span><br><span class="line">  &#x2F;&#x2F;将执行完的call从正在运行的队列中移除，并进行promoteAndExecute()操作，将在ready队列中的call放进running队列中继续执行</span><br><span class="line">  finished(runningAsyncCalls, call)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-2、同步请求流程excute-："><a href="#2-3-2、同步请求流程excute-：" class="headerlink" title="2.3.2、同步请求流程excute()："></a>2.3.2、同步请求流程excute()：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override fun execute(): Response &#123;</span><br><span class="line">  synchronized(this) &#123;</span><br><span class="line">    check(!executed) &#123; &quot;Already Executed&quot; &#125;</span><br><span class="line">    executed &#x3D; true</span><br><span class="line">  &#125;</span><br><span class="line">  timeout.enter()</span><br><span class="line">  callStart()</span><br><span class="line">  try &#123;</span><br><span class="line">  &#x2F;&#x2F;直接将这个call交给了Dispatcher执行，会直接将call添加到runningSyncCalls</span><br><span class="line">    client.dispatcher.executed(this)</span><br><span class="line">    &#x2F;&#x2F;直接将结果返回</span><br><span class="line">    return getResponseWithInterceptorChain()</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    client.dispatcher.finished(this)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、几大拦截器分析："><a href="#三、几大拦截器分析：" class="headerlink" title="三、几大拦截器分析："></a>三、几大拦截器分析：</h1><p>​    在OkHttp当中真正去做网络请求的是在他的各个拦截器当中，这里用到了责任链模式，链上的每个拦截器都可以对当前request进行处理，<br>​    当结果返回时，每个拦截器都可以对response进行处理</p>
<h2 id="RealInterceptorChain："><a href="#RealInterceptorChain：" class="headerlink" title="RealInterceptorChain："></a>RealInterceptorChain：</h2><p>他将所有的拦截器串在了一起，当在RealCall的getResponseWithInterceptorChain()会将所有的拦截器添加到RealInterceptorChain的一个List集合当中</p>
<h3 id="RealCall-getResponseWithInterceptorChain-："><a href="#RealCall-getResponseWithInterceptorChain-：" class="headerlink" title="RealCall#getResponseWithInterceptorChain()："></a>RealCall#getResponseWithInterceptorChain()：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">internal fun getResponseWithInterceptorChain(): Response &#123;</span><br><span class="line">    </span><br><span class="line">    val interceptors &#x3D; mutableListOf&lt;Interceptor&gt;()</span><br><span class="line">    &#x2F;&#x2F;将链上的所有拦截器添加到集合当中</span><br><span class="line">    interceptors +&#x3D; client.interceptors</span><br><span class="line">    interceptors +&#x3D; RetryAndFollowUpInterceptor(client)</span><br><span class="line">    interceptors +&#x3D; BridgeInterceptor(client.cookieJar)</span><br><span class="line">    interceptors +&#x3D; CacheInterceptor(client.cache)</span><br><span class="line">    interceptors +&#x3D; ConnectInterceptor</span><br><span class="line">    if (!forWebSocket) &#123;</span><br><span class="line">      interceptors +&#x3D; client.networkInterceptors</span><br><span class="line">    &#125;</span><br><span class="line">    interceptors +&#x3D; CallServerInterceptor(forWebSocket)</span><br><span class="line">    &#x2F;&#x2F;构建链条</span><br><span class="line">    val chain &#x3D; RealInterceptorChain(</span><br><span class="line">        call &#x3D; this,</span><br><span class="line">        interceptors &#x3D; interceptors,</span><br><span class="line">        &#x2F;&#x2F;起始传入0，会先让链条上的第一个拦截器工作起来</span><br><span class="line">        index &#x3D; 0,</span><br><span class="line">        exchange &#x3D; null,</span><br><span class="line">        request &#x3D; originalRequest,</span><br><span class="line">        connectTimeoutMillis &#x3D; client.connectTimeoutMillis,</span><br><span class="line">        readTimeoutMillis &#x3D; client.readTimeoutMillis,</span><br><span class="line">        writeTimeoutMillis &#x3D; client.writeTimeoutMillis</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    var calledNoMoreExchanges &#x3D; false</span><br><span class="line">   </span><br><span class="line">    &#x2F;&#x2F;这里才是整个链条真正开始的地方</span><br><span class="line">      val response &#x3D; chain.proceed(originalRequest)</span><br><span class="line">       &#x2F;&#x2F;省略部分代码...</span><br><span class="line">      return response</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="RealCall-proceed："><a href="#RealCall-proceed：" class="headerlink" title="RealCall#proceed："></a>RealCall#proceed：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override fun proceed(request: Request): Response &#123;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;省略部分代码...</span><br><span class="line">   &#x2F;&#x2F; 先copy了一个chain出来</span><br><span class="line">   val next &#x3D; copy(index &#x3D; index + 1, request &#x3D; request)</span><br><span class="line">   &#x2F;&#x2F;拿到当前应该执行的拦截器</span><br><span class="line">   val interceptor &#x3D; interceptors[index]</span><br><span class="line"></span><br><span class="line">   @Suppress(&quot;USELESS_ELVIS&quot;)</span><br><span class="line">   &#x2F;&#x2F;调用拦截器的intercept方法</span><br><span class="line">   val response &#x3D; interceptor.intercept(next) ?: throw NullPointerException(</span><br><span class="line">       &quot;interceptor $interceptor returned null&quot;)</span><br><span class="line">       </span><br><span class="line">   &#x2F;&#x2F;省略部分代码...</span><br><span class="line">   return response</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-1、RetryAndFollowUpInterceptor："><a href="#3-1、RetryAndFollowUpInterceptor：" class="headerlink" title="3.1、RetryAndFollowUpInterceptor："></a>3.1、RetryAndFollowUpInterceptor：</h2><p> 重试和重定向拦截器</p>
<h3 id="RetryAndFollowUpInterceptor-interceptor"><a href="#RetryAndFollowUpInterceptor-interceptor" class="headerlink" title="RetryAndFollowUpInterceptor#interceptor():"></a>RetryAndFollowUpInterceptor#interceptor():</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override fun intercept(chain: Interceptor.Chain): Response &#123;</span><br><span class="line">   val realChain &#x3D; chain as RealInterceptorChain</span><br><span class="line">   var request &#x3D; chain.request</span><br><span class="line">   val call &#x3D; realChain.call</span><br><span class="line">   var followUpCount &#x3D; 0</span><br><span class="line">   var priorResponse: Response? &#x3D; null</span><br><span class="line">   var newExchangeFinder &#x3D; true</span><br><span class="line">   &#x2F;&#x2F;如果失败会一直重试，当然会根据一定的条件，条件不满足会跳出循环</span><br><span class="line">   while (true) &#123;</span><br><span class="line">   &#x2F;&#x2F;会将RealCall当中的exchangeFinder创建一个新的ExchangeFinder给他</span><br><span class="line">     call.enterNetworkInterceptorExchange(request, newExchangeFinder)</span><br><span class="line"></span><br><span class="line">     var response: Response</span><br><span class="line">     var closeActiveExchange &#x3D; true</span><br><span class="line">     try &#123;</span><br><span class="line">     &#x2F;&#x2F;如果当前的call已经cancle掉了，直接抛出异常</span><br><span class="line">       if (call.isCanceled()) &#123;</span><br><span class="line">         throw IOException(&quot;Canceled&quot;)</span><br><span class="line">       &#125;</span><br><span class="line">       try &#123;</span><br><span class="line">       &#x2F;&#x2F;执行链上下一个拦截器</span><br><span class="line">         response &#x3D; realChain.proceed(request)</span><br><span class="line">         newExchangeFinder &#x3D; true</span><br><span class="line">       &#125; catch (e: RouteException) &#123;</span><br><span class="line">         &#x2F;&#x2F; 如果出现异常，看这个连接是否能恢复</span><br><span class="line">         if (!recover(e.lastConnectException, call, request, requestSendStarted &#x3D; false)) &#123;</span><br><span class="line">           throw e.firstConnectException</span><br><span class="line">         &#125;</span><br><span class="line">         &#x2F;&#x2F;如果出现异常了，并且是可恢复的，那么会再次进入这个循环，将这个newExchangeFinder置为false，在</span><br><span class="line">         &#x2F;&#x2F;call.enterNetworkInterceptorExchange(request, newExchangeFinder)传入的就是一个false的，表示不会创建一个新的exchangeFinder</span><br><span class="line">         newExchangeFinder &#x3D; false</span><br><span class="line">         continue</span><br><span class="line">       &#125; catch (e: IOException) &#123;</span><br><span class="line">         &#x2F;&#x2F; 出现IO异常同样会去判断连接是否能恢复</span><br><span class="line">         if (!recover(e, call, request, requestSendStarted &#x3D; e !is ConnectionShutdownException)) &#123;</span><br><span class="line">           throw e</span><br><span class="line">         &#125;</span><br><span class="line">         newExchangeFinder &#x3D; false</span><br><span class="line">         continue</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       val exchange &#x3D; call.interceptorScopedExchange</span><br><span class="line">       val followUp &#x3D; followUpRequest(response, exchange)</span><br><span class="line"></span><br><span class="line">       if (followUp &#x3D;&#x3D; null) &#123;</span><br><span class="line">         if (exchange !&#x3D; null &amp;&amp; exchange.isDuplex) &#123;</span><br><span class="line">           call.timeoutEarlyExit()</span><br><span class="line">         &#125;</span><br><span class="line">         closeActiveExchange &#x3D; false</span><br><span class="line">         return response</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       val followUpBody &#x3D; followUp.body</span><br><span class="line">       if (followUpBody !&#x3D; null &amp;&amp; followUpBody.isOneShot()) &#123;</span><br><span class="line">         closeActiveExchange &#x3D; false</span><br><span class="line">         return response</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       response.body?.closeQuietly()</span><br><span class="line">       &#x2F;&#x2F;重定向次数不能大于20次，这个值是参考了其他浏览器内核的Chrome是21次、Safari 16次</span><br><span class="line">       if (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class="line">         throw ProtocolException(&quot;Too many follow-up requests: $followUpCount&quot;)</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;省略部分代码...</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="RetryAndFollowUpInterceptor-recover"><a href="#RetryAndFollowUpInterceptor-recover" class="headerlink" title="RetryAndFollowUpInterceptor#recover():"></a>RetryAndFollowUpInterceptor#recover():</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private fun recover(</span><br><span class="line">  e: IOException,</span><br><span class="line">  call: RealCall,</span><br><span class="line">  userRequest: Request,</span><br><span class="line">  requestSendStarted: Boolean</span><br><span class="line">): Boolean &#123;</span><br><span class="line">  &#x2F;&#x2F; 如果我们配置了不允许重试，直接返回false</span><br><span class="line">  if (!client.retryOnConnectionFailure) return false</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; We can&#39;t send the request body again.</span><br><span class="line">  if (requestSendStarted &amp;&amp; requestIsOneShot(e, userRequest)) return false</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 如果发生了异常</span><br><span class="line">  if (!isRecoverable(e, requestSendStarted)) return false</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 没用更多的路由方式选择</span><br><span class="line">  if (!call.retryAfterFailure()) return false</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; For failure recovery, use the same route selector with a new connection.</span><br><span class="line">  return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RetryAndFollowUpInterceptor-isRecoverable"><a href="#RetryAndFollowUpInterceptor-isRecoverable" class="headerlink" title="RetryAndFollowUpInterceptor#isRecoverable():"></a>RetryAndFollowUpInterceptor#isRecoverable():</h3><p>是否是可恢复的异常</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private fun isRecoverable(e: IOException, requestSendStarted: Boolean): Boolean &#123;</span><br><span class="line">  &#x2F;&#x2F; 如果协议发生异常，例如服务端不支持的协议</span><br><span class="line">  if (e is ProtocolException) &#123;</span><br><span class="line">    return false</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 如果是连接超时，</span><br><span class="line">  if (e is InterruptedIOException) &#123;</span><br><span class="line">    return e is SocketTimeoutException &amp;&amp; !requestSendStarted</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 建立ssl出现异常，证书认证失败</span><br><span class="line">  if (e is SSLHandshakeException) &#123;</span><br><span class="line">    if (e.cause is CertificateException) &#123;</span><br><span class="line">      return false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：上面就是重试和重定向的拦截器，在连接过程中如果出现了异常，会进行重试，或者需要重定向时都会一直重试，在重试的过程中会进行一系列的条件判断，来判断当前请求是否<br>达到重试的规则，才会进行重试。</p>
<h2 id="3-2、BridgeInterceptor："><a href="#3-2、BridgeInterceptor：" class="headerlink" title="3.2、BridgeInterceptor："></a>3.2、BridgeInterceptor：</h2><p>这个拦截器的主要作用时，添加request过程中的header，以及对response当中的header进行处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override fun intercept(chain: Interceptor.Chain): Response &#123;</span><br><span class="line">  val userRequest &#x3D; chain.request()</span><br><span class="line">  val requestBuilder &#x3D; userRequest.newBuilder()</span><br><span class="line"></span><br><span class="line">  val body &#x3D; userRequest.body</span><br><span class="line">  if (body !&#x3D; null) &#123;</span><br><span class="line">    val contentType &#x3D; body.contentType()</span><br><span class="line">    if (contentType !&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F;添加Content-type</span><br><span class="line">      requestBuilder.header(&quot;Content-Type&quot;, contentType.toString())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val contentLength &#x3D; body.contentLength()</span><br><span class="line">    if (contentLength !&#x3D; -1L) &#123;</span><br><span class="line">    &#x2F;&#x2F;添加Content-Length</span><br><span class="line">      requestBuilder.header(&quot;Content-Length&quot;, contentLength.toString())</span><br><span class="line">      requestBuilder.removeHeader(&quot;Transfer-Encoding&quot;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      requestBuilder.header(&quot;Transfer-Encoding&quot;, &quot;chunked&quot;)</span><br><span class="line">      requestBuilder.removeHeader(&quot;Content-Length&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;请求报文中的Host</span><br><span class="line">  if (userRequest.header(&quot;Host&quot;) &#x3D;&#x3D; null) &#123;</span><br><span class="line">    requestBuilder.header(&quot;Host&quot;, userRequest.url.toHostHeader())</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;Connection  的header</span><br><span class="line">  if (userRequest.header(&quot;Connection&quot;) &#x3D;&#x3D; null) &#123;</span><br><span class="line">    requestBuilder.header(&quot;Connection&quot;, &quot;Keep-Alive&quot;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;默认会对我们的请求和响应进行gzip的压缩</span><br><span class="line">  var transparentGzip &#x3D; false</span><br><span class="line">  if (userRequest.header(&quot;Accept-Encoding&quot;) &#x3D;&#x3D; null &amp;&amp; userRequest.header(&quot;Range&quot;) &#x3D;&#x3D; null) &#123;</span><br><span class="line">    transparentGzip &#x3D; true</span><br><span class="line">    requestBuilder.header(&quot;Accept-Encoding&quot;, &quot;gzip&quot;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  val cookies &#x3D; cookieJar.loadForRequest(userRequest.url)</span><br><span class="line">  if (cookies.isNotEmpty()) &#123;</span><br><span class="line">    requestBuilder.header(&quot;Cookie&quot;, cookieHeader(cookies))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (userRequest.header(&quot;User-Agent&quot;) &#x3D;&#x3D; null) &#123;</span><br><span class="line">    requestBuilder.header(&quot;User-Agent&quot;, userAgent)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  val networkResponse &#x3D; chain.proceed(requestBuilder.build())</span><br><span class="line"></span><br><span class="line">  cookieJar.receiveHeaders(userRequest.url, networkResponse.headers)</span><br><span class="line"></span><br><span class="line">  val responseBuilder &#x3D; networkResponse.newBuilder()</span><br><span class="line">      .request(userRequest)</span><br><span class="line"></span><br><span class="line">  if (transparentGzip &amp;&amp;</span><br><span class="line">      &quot;gzip&quot;.equals(networkResponse.header(&quot;Content-Encoding&quot;), ignoreCase &#x3D; true) &amp;&amp;</span><br><span class="line">      networkResponse.promisesBody()) &#123;</span><br><span class="line">    val responseBody &#x3D; networkResponse.body</span><br><span class="line">    if (responseBody !&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F;对response中的数据进行Gzip的解压</span><br><span class="line">      val gzipSource &#x3D; GzipSource(responseBody.source())</span><br><span class="line">      val strippedHeaders &#x3D; networkResponse.headers.newBuilder()</span><br><span class="line">          .removeAll(&quot;Content-Encoding&quot;)</span><br><span class="line">          .removeAll(&quot;Content-Length&quot;)</span><br><span class="line">          .build()</span><br><span class="line">      responseBuilder.headers(strippedHeaders)</span><br><span class="line">      val contentType &#x3D; networkResponse.header(&quot;Content-Type&quot;)</span><br><span class="line">      responseBuilder.body(RealResponseBody(contentType, -1L, gzipSource.buffer()))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return responseBuilder.build()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：这个拦截器的作用就是对我们请求过程的header做统一的添加处理，不需要用户再手动的去处理这些报文当中的header</p>
<h2 id="3-3、CacheInterceptor："><a href="#3-3、CacheInterceptor：" class="headerlink" title="3.3、CacheInterceptor："></a>3.3、CacheInterceptor：</h2><p>看缓存当中的信息能不能直接给当前call直接使用，或者对当次response做缓存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override fun intercept(chain: Interceptor.Chain): Response &#123;</span><br><span class="line">&#x2F;&#x2F;先直接从缓存当中拿一次</span><br><span class="line">  val cacheCandidate &#x3D; cache?.get(chain.request())</span><br><span class="line"></span><br><span class="line">  val now &#x3D; System.currentTimeMillis()</span><br><span class="line">  &#x2F;&#x2F;根据http的缓存判断方式来判断，Http会根据Date、Expires、Last-Modified、ETag、Age等header来判断缓存有效性</span><br><span class="line">  val strategy &#x3D; CacheStrategy.Factory(now, chain.request(), cacheCandidate).compute()</span><br><span class="line">  val networkRequest &#x3D; strategy.networkRequest</span><br><span class="line">  val cacheResponse &#x3D; strategy.cacheResponse</span><br><span class="line">  </span><br><span class="line">  cache?.trackResponse(strategy)</span><br><span class="line">  </span><br><span class="line">  if (cacheCandidate !&#x3D; null &amp;&amp; cacheResponse &#x3D;&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; The cache candidate wasn&#39;t applicable. Close it.</span><br><span class="line">    cacheCandidate.body?.closeQuietly()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 如果网络和缓存都不可用，直接返回504</span><br><span class="line">  if (networkRequest &#x3D;&#x3D; null &amp;&amp; cacheResponse &#x3D;&#x3D; null) &#123;</span><br><span class="line">    return Response.Builder()</span><br><span class="line">        .request(chain.request())</span><br><span class="line">        .protocol(Protocol.HTTP_1_1)</span><br><span class="line">        .code(HTTP_GATEWAY_TIMEOUT)</span><br><span class="line">        .message(&quot;Unsatisfiable Request (only-if-cached)&quot;)</span><br><span class="line">        .body(EMPTY_RESPONSE)</span><br><span class="line">        .sentRequestAtMillis(-1L)</span><br><span class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">        .build()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 缓存当中有，直接从缓存当中获取</span><br><span class="line">  if (networkRequest &#x3D;&#x3D; null) &#123;</span><br><span class="line">    return cacheResponse!!.newBuilder()</span><br><span class="line">        .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">        .build()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var networkResponse: Response? &#x3D; null</span><br><span class="line">  try &#123;</span><br><span class="line">    networkResponse &#x3D; chain.proceed(networkRequest)</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    &#x2F;&#x2F; If we&#39;re crashing on I&#x2F;O or otherwise, don&#39;t leak the cache body.</span><br><span class="line">    if (networkResponse &#x3D;&#x3D; null &amp;&amp; cacheCandidate !&#x3D; null) &#123;</span><br><span class="line">      cacheCandidate.body?.closeQuietly()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 如果当前返回的时304，服务端数据没用变化，则会将缓存的数据的时间有效性进行更新</span><br><span class="line">  if (cacheResponse !&#x3D; null) &#123;</span><br><span class="line">    if (networkResponse?.code &#x3D;&#x3D; HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">      val response &#x3D; cacheResponse.newBuilder()</span><br><span class="line">          .headers(combine(cacheResponse.headers, networkResponse.headers))</span><br><span class="line">          .sentRequestAtMillis(networkResponse.sentRequestAtMillis)</span><br><span class="line">          .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis)</span><br><span class="line">          .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">          .networkResponse(stripBody(networkResponse))</span><br><span class="line">          .build()</span><br><span class="line"></span><br><span class="line">      networkResponse.body!!.close()</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; Update the cache after combining headers but before stripping the</span><br><span class="line">      &#x2F;&#x2F; Content-Encoding header (as performed by initContentStream()).</span><br><span class="line">      cache!!.trackConditionalCacheHit()</span><br><span class="line">      cache.update(cacheResponse, response)</span><br><span class="line">      return response</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      cacheResponse.body?.closeQuietly()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  val response &#x3D; networkResponse!!.newBuilder()</span><br><span class="line">      .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">      .networkResponse(stripBody(networkResponse))</span><br><span class="line">      .build()</span><br><span class="line"></span><br><span class="line">  if (cache !&#x3D; null) &#123;</span><br><span class="line">    if (response.promisesBody() &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">      &#x2F;&#x2F; Offer this request to the cache.</span><br><span class="line">      val cacheRequest &#x3D; cache.put(response)</span><br><span class="line">      return cacheWritingResponse(cacheRequest, response)</span><br><span class="line">    &#125;</span><br><span class="line">     &#x2F;&#x2F;非POST、PATCH、PUT、DELETE、MOVE请求方式才能被缓存</span><br><span class="line">    if (HttpMethod.invalidatesCache(networkRequest.method)) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        cache.remove(networkRequest)</span><br><span class="line">      &#125; catch (_: IOException) &#123;</span><br><span class="line">        &#x2F;&#x2F; The cache cannot be written.</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return response</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：缓存拦截器主要目的就是用来判断当前请求在缓存中是否存在，并判断缓存有效性，有效则直接返回，没有缓存直接通过网络获取，获取下来之后需要进行缓存供下一次使用，在判断缓存有效性过程中是通过Http的缓存有效性来判断的。</p>
<h2 id="3-4、ConnectInterceptor："><a href="#3-4、ConnectInterceptor：" class="headerlink" title="3.4、ConnectInterceptor："></a>3.4、ConnectInterceptor：</h2><p>连接拦截器，这个拦截器中的interceptor最简单，但是内部结果最为复杂，会到连接池当中去获取可重用的连接，来避免重复连接。</p>
<h3 id="1、"><a href="#1、" class="headerlink" title="1、"></a>1、</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override fun intercept(chain: Interceptor.Chain): Response &#123;</span><br><span class="line">        val realChain &#x3D; chain as RealInterceptorChain</span><br><span class="line">        &#x2F;&#x2F;得到一个Exchange</span><br><span class="line">        val exchange &#x3D; realChain.call.initExchange(chain)</span><br><span class="line">        val connectedChain &#x3D; realChain.copy(exchange &#x3D; exchange)</span><br><span class="line">        &#x2F;&#x2F;这个拦截器就是最后一个拦截器了，没有后续工作</span><br><span class="line">        return connectedChain.proceed(realChain.request)</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、RealCall-initExchange-："><a href="#2、RealCall-initExchange-：" class="headerlink" title="2、RealCall#initExchange()："></a>2、RealCall#initExchange()：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">internal fun initExchange(chain: RealInterceptorChain): Exchange &#123;</span><br><span class="line"> &#x2F;&#x2F;省略部分代码...</span><br><span class="line"> &#x2F;&#x2F;exchangeFinder在调用重试拦截器时就已经初始化过</span><br><span class="line">  val codec &#x3D; exchangeFinder!!.find(client, chain)</span><br><span class="line">  </span><br><span class="line">  val result &#x3D; Exchange(this, eventListener, exchangeFinder!!, codec)</span><br><span class="line">  this.interceptorScopedExchange &#x3D; result</span><br><span class="line"></span><br><span class="line">  synchronized(connectionPool) &#123;</span><br><span class="line">    this.exchange &#x3D; result</span><br><span class="line">    this.exchangeRequestDone &#x3D; false</span><br><span class="line">    this.exchangeResponseDone &#x3D; false</span><br><span class="line">    return result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、ExChangeFinder-find-："><a href="#3、ExChangeFinder-find-：" class="headerlink" title="3、ExChangeFinder#find()："></a>3、ExChangeFinder#find()：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun find(</span><br><span class="line">    client: OkHttpClient,</span><br><span class="line">    chain: RealInterceptorChain</span><br><span class="line">  ): ExchangeCodec &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">    &#x2F;&#x2F;去找到一个健康的连接</span><br><span class="line">      val resultConnection &#x3D; findHealthyConnection(</span><br><span class="line">          connectTimeout &#x3D; chain.connectTimeoutMillis,</span><br><span class="line">          readTimeout &#x3D; chain.readTimeoutMillis,</span><br><span class="line">          writeTimeout &#x3D; chain.writeTimeoutMillis,</span><br><span class="line">          pingIntervalMillis &#x3D; client.pingIntervalMillis,</span><br><span class="line">          connectionRetryEnabled &#x3D; client.retryOnConnectionFailure,</span><br><span class="line">          doExtensiveHealthChecks &#x3D; chain.request.method !&#x3D; &quot;GET&quot;</span><br><span class="line">      )</span><br><span class="line">      return resultConnection.newCodec(client, chain)</span><br><span class="line">    &#125; catch (e: RouteException) &#123;</span><br><span class="line">      trackFailure(e.lastConnectException)</span><br><span class="line">      throw e</span><br><span class="line">    &#125; catch (e: IOException) &#123;</span><br><span class="line">      trackFailure(e)</span><br><span class="line">      throw RouteException(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<h3 id="4、ExChangeFinder-findHealthyConnection-："><a href="#4、ExChangeFinder-findHealthyConnection-：" class="headerlink" title="4、ExChangeFinder#findHealthyConnection()："></a>4、ExChangeFinder#findHealthyConnection()：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private fun findHealthyConnection(</span><br><span class="line">  connectTimeout: Int,</span><br><span class="line">  readTimeout: Int,</span><br><span class="line">  writeTimeout: Int,</span><br><span class="line">  pingIntervalMillis: Int,</span><br><span class="line">  connectionRetryEnabled: Boolean,</span><br><span class="line">  doExtensiveHealthChecks: Boolean</span><br><span class="line">): RealConnection &#123;</span><br><span class="line">  while (true) &#123;</span><br><span class="line">  &#x2F;&#x2F;从连接池中获取一个连接</span><br><span class="line">    val candidate &#x3D; findConnection(</span><br><span class="line">        connectTimeout &#x3D; connectTimeout,</span><br><span class="line">        readTimeout &#x3D; readTimeout,</span><br><span class="line">        writeTimeout &#x3D; writeTimeout,</span><br><span class="line">        pingIntervalMillis &#x3D; pingIntervalMillis,</span><br><span class="line">        connectionRetryEnabled &#x3D; connectionRetryEnabled</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 对从连接池中获取到的连接再次确认，http1和http2的连接都会确认他是否关闭，http2的连接还会确认他的ping pong值</span><br><span class="line">    if (!candidate.isHealthy(doExtensiveHealthChecks)) &#123;</span><br><span class="line">      candidate.noNewExchanges()</span><br><span class="line">      continue</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return candidate</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、ExchangeFinder-findConnection-："><a href="#5、ExchangeFinder-findConnection-：" class="headerlink" title="5、ExchangeFinder#findConnection()："></a>5、ExchangeFinder#findConnection()：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private fun findConnection(</span><br><span class="line">    connectTimeout: Int,</span><br><span class="line">    readTimeout: Int,</span><br><span class="line">    writeTimeout: Int,</span><br><span class="line">    pingIntervalMillis: Int,</span><br><span class="line">    connectionRetryEnabled: Boolean</span><br><span class="line">  ): RealConnection &#123;</span><br><span class="line">    var foundPooledConnection &#x3D; false</span><br><span class="line">    var result: RealConnection? &#x3D; null</span><br><span class="line">    var selectedRoute: Route? &#x3D; null</span><br><span class="line">    var releasedConnection: RealConnection?</span><br><span class="line">    val toClose: Socket?</span><br><span class="line">    synchronized(connectionPool) &#123;</span><br><span class="line">      if (call.isCanceled()) throw IOException(&quot;Canceled&quot;)</span><br><span class="line">        </span><br><span class="line">      val callConnection &#x3D; call.connection &#x2F;&#x2F; changes within this overall method</span><br><span class="line">      releasedConnection &#x3D; callConnection</span><br><span class="line">      &#x2F;&#x2F;首次进来时，这个肯定是空的可以先不看  出现异常进来时，call不为null，那么看当前这个call的端口等等是不是一样，不一样那么将这个call释放掉</span><br><span class="line">      toClose &#x3D; if (callConnection !&#x3D; null &amp;&amp; (callConnection.noNewExchanges ||</span><br><span class="line">              !sameHostAndPort(callConnection.route().address.url))) &#123;</span><br><span class="line">        call.releaseConnectionNoEvents()</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        null</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F;首次进来时，这个肯定是空的可以先不看</span><br><span class="line">      if (call.connection !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; We had an already-allocated connection and it&#39;s good.</span><br><span class="line">        result &#x3D; call.connection</span><br><span class="line">        releasedConnection &#x3D; null</span><br><span class="line">      &#125;</span><br><span class="line">       </span><br><span class="line">      if (result &#x3D;&#x3D; null) &#123;</span><br><span class="line">        refusedStreamCount &#x3D; 0</span><br><span class="line">        connectionShutdownCount &#x3D; 0</span><br><span class="line">        otherFailureCount &#x3D; 0</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 2、从连接池当中获取连接，只找不是多路复用的，多路复用是在Http2当中有的，所谓的多路复用是指当两个连接的主机一样且他们的访问路径一样时，可以重用</span><br><span class="line">        &#x2F;&#x2F;连接，而不用再重新开新的连接。在判断当前连接池当中是否存在可用连接时</span><br><span class="line">        if (connectionPool.callAcquirePooledConnection(address, call, null, false)) &#123;</span><br><span class="line">          foundPooledConnection &#x3D; true</span><br><span class="line">          result &#x3D; call.connection</span><br><span class="line">        &#125; else if (nextRouteToTry !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F;上一次释放掉的与当前call同时被创建的，失败时可以重用这个被释放掉的，就不用去进行</span><br><span class="line">          selectedRoute &#x3D; nextRouteToTry</span><br><span class="line">          nextRouteToTry &#x3D; null</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    toClose?.closeQuietly()</span><br><span class="line"></span><br><span class="line">    if (releasedConnection !&#x3D; null) &#123;</span><br><span class="line">      eventListener.connectionReleased(call, releasedConnection!!)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (foundPooledConnection) &#123;</span><br><span class="line">      eventListener.connectionAcquired(call, result!!)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;找到可用连接，直接返回</span><br><span class="line">    if (result !&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; If we found an already-allocated or pooled connection, we&#39;re done.</span><br><span class="line">      return result!!</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 前面只会找直连且不支持多路复用的连接</span><br><span class="line">    var newRouteSelection &#x3D; false</span><br><span class="line">    &#x2F;&#x2F;因为我们的主机可能指向多个IP地址，也可能存在代理连接的方式，且代理连接也存在多个IP地址的情况，所以会再查找一次</span><br><span class="line">    if (selectedRoute &#x3D;&#x3D; null &amp;&amp; (routeSelection &#x3D;&#x3D; null || !routeSelection!!.hasNext())) &#123;</span><br><span class="line">      var localRouteSelector &#x3D; routeSelector</span><br><span class="line">      if (localRouteSelector &#x3D;&#x3D; null) &#123;</span><br><span class="line">      &#x2F;**</span><br><span class="line">      *RouteSelector这个就是路由，例如：</span><br><span class="line">        直连主机：http:&#x2F;&#x2F;www.baidu.com</span><br><span class="line">        直连IP：</span><br><span class="line">         1.1.1.1:80</span><br><span class="line">         2.2.2.2:80</span><br><span class="line">        代理主机：https:&#x2F;&#x2F;www.baidu.com</span><br><span class="line">        代理对应IP：</span><br><span class="line">         11.11.11.11:443</span><br><span class="line">         12.12.12.12:443</span><br><span class="line">         13.13.13.13:443</span><br><span class="line">      那么直连IP与代理IP就组成了一个RouteSelector</span><br><span class="line">      而直连IP和代理IP对应的就是两个Selection</span><br><span class="line">      *&#x2F;</span><br><span class="line">        localRouteSelector &#x3D; RouteSelector(address, call.client.routeDatabase, call, eventListener)</span><br><span class="line">        this.routeSelector &#x3D; localRouteSelector</span><br><span class="line">      &#125;</span><br><span class="line">      newRouteSelection &#x3D; true</span><br><span class="line">      routeSelection &#x3D; localRouteSelector.next()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var routes: List&lt;Route&gt;? &#x3D; null</span><br><span class="line">    synchronized(connectionPool) &#123;</span><br><span class="line">      if (call.isCanceled()) throw IOException(&quot;Canceled&quot;)</span><br><span class="line"></span><br><span class="line">      if (newRouteSelection) &#123;</span><br><span class="line">        &#x2F;&#x2F;这个routes就是直连或者代理对应的不同的IP</span><br><span class="line">        routes &#x3D; routeSelection!!.routes</span><br><span class="line">        &#x2F;&#x2F;3、从路由当中去找，也是找非多路复用的</span><br><span class="line">        if (connectionPool.callAcquirePooledConnection(address, call, routes, false)) &#123;</span><br><span class="line">          foundPooledConnection &#x3D; true</span><br><span class="line">          result &#x3D; call.connection</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (!foundPooledConnection) &#123;</span><br><span class="line">        if (selectedRoute &#x3D;&#x3D; null) &#123;</span><br><span class="line">          selectedRoute &#x3D; routeSelection!!.next()</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;直接创建RealConnection，selectedRoute是上一次释放掉的</span><br><span class="line">    result &#x3D; RealConnection(connectionPool, selectedRoute!!)</span><br><span class="line">    connectingConnection &#x3D; result</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 从连接池当中找到一个连接，直接返回</span><br><span class="line">    if (foundPooledConnection) &#123;</span><br><span class="line">      eventListener.connectionAcquired(call, result!!)</span><br><span class="line">      return result!!</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;4、如果前面两次都没找到连接，则直接创建一个新的连接</span><br><span class="line">    result!!.connect(</span><br><span class="line">        connectTimeout,</span><br><span class="line">        readTimeout,</span><br><span class="line">        writeTimeout,</span><br><span class="line">        pingIntervalMillis,</span><br><span class="line">        connectionRetryEnabled,</span><br><span class="line">        call,</span><br><span class="line">        eventListener</span><br><span class="line">    )</span><br><span class="line">    call.client.routeDatabase.connected(result!!.route())</span><br><span class="line"></span><br><span class="line">    var socket: Socket? &#x3D; null</span><br><span class="line">    synchronized(connectionPool) &#123;</span><br><span class="line">      connectingConnection &#x3D; null</span><br><span class="line">      &#x2F;&#x2F; 5、再从连接池当中获取一次，因为可能存在两个主机相同的连接都创建了 的情况，如果两个连接都创建了，在这里再获取一次，可用减少连接</span><br><span class="line">      if (connectionPool.callAcquirePooledConnection(address, call, routes, true)) &#123;</span><br><span class="line">        &#x2F;&#x2F; 将后建立的连接直接关闭</span><br><span class="line">        result!!.noNewExchanges &#x3D; true</span><br><span class="line">        socket &#x3D; result!!.socket()</span><br><span class="line">        result &#x3D; call.connection</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 将后面这个路由保存，以防在他前面建立的连接马上被关闭了，他可用拿着这个连接直接重用，就不用再重新查找</span><br><span class="line">        nextRouteToTry &#x3D; selectedRoute</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F;将找到的连接存入连接池中</span><br><span class="line">        connectionPool.put(result!!)</span><br><span class="line">        call.acquireConnectionNoEvents(result!!)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    socket?.closeQuietly()</span><br><span class="line"></span><br><span class="line">    eventListener.connectionAcquired(call, result!!)</span><br><span class="line">    return result!!</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、RealConnectionPool-callAcquirePooledConnection-："><a href="#6、RealConnectionPool-callAcquirePooledConnection-：" class="headerlink" title="6、RealConnectionPool#callAcquirePooledConnection()："></a>6、RealConnectionPool#callAcquirePooledConnection()：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun callAcquirePooledConnection(</span><br><span class="line">  address: Address,</span><br><span class="line">  call: RealCall,</span><br><span class="line">  routes: List&lt;Route&gt;?,</span><br><span class="line">  requireMultiplexed: Boolean</span><br><span class="line">): Boolean &#123;</span><br><span class="line">  this.assertThreadHoldsLock()</span><br><span class="line"></span><br><span class="line">  for (connection in connections) &#123;</span><br><span class="line">  &#x2F;&#x2F;如果传入的是要找多路复用，但当前连接不支持多路复用的，继续寻找下一个</span><br><span class="line">    if (requireMultiplexed &amp;&amp; !connection.isMultiplexed) continue</span><br><span class="line">     &#x2F;&#x2F;判断当前连接和池中的连接是否是一样的，</span><br><span class="line">    if (!connection.isEligible(address, routes)) continue</span><br><span class="line">    &#x2F;&#x2F;找到可用连接</span><br><span class="line">    call.acquireConnectionNoEvents(connection)</span><br><span class="line">    return true</span><br><span class="line">  &#125;</span><br><span class="line">  return false</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7、Address-equalsNonHost-："><a href="#7、Address-equalsNonHost-：" class="headerlink" title="7、Address#equalsNonHost()："></a>7、Address#equalsNonHost()：</h3><p>//判断除域名以外的所有连接信息是否一致，例如：路由方式、协议、证书、端口等等</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">internal fun equalsNonHost(that: Address): Boolean &#123;</span><br><span class="line">  return this.dns &#x3D;&#x3D; that.dns &amp;&amp;</span><br><span class="line">      this.proxyAuthenticator &#x3D;&#x3D; that.proxyAuthenticator &amp;&amp;</span><br><span class="line">      this.protocols &#x3D;&#x3D; that.protocols &amp;&amp;</span><br><span class="line">      this.connectionSpecs &#x3D;&#x3D; that.connectionSpecs &amp;&amp;</span><br><span class="line">      this.proxySelector &#x3D;&#x3D; that.proxySelector &amp;&amp;</span><br><span class="line">      this.proxy &#x3D;&#x3D; that.proxy &amp;&amp;</span><br><span class="line">      this.sslSocketFactory &#x3D;&#x3D; that.sslSocketFactory &amp;&amp;</span><br><span class="line">      this.hostnameVerifier &#x3D;&#x3D; that.hostnameVerifier &amp;&amp;</span><br><span class="line">      this.certificatePinner &#x3D;&#x3D; that.certificatePinner &amp;&amp;</span><br><span class="line">      this.url.port &#x3D;&#x3D; that.url.port</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8、RealConnection-connect-："><a href="#8、RealConnection-connect-：" class="headerlink" title="8、RealConnection#connect()："></a>8、RealConnection#connect()：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun connect(</span><br><span class="line">    connectTimeout: Int,</span><br><span class="line">    readTimeout: Int,</span><br><span class="line">    writeTimeout: Int,</span><br><span class="line">    pingIntervalMillis: Int,</span><br><span class="line">    connectionRetryEnabled: Boolean,</span><br><span class="line">    call: Call,</span><br><span class="line">    eventListener: EventListener</span><br><span class="line">  ) &#123;</span><br><span class="line">    &#x2F;&#x2F;省略部分代码...</span><br><span class="line"></span><br><span class="line">    while (true) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">      &#x2F;&#x2F;Tunnel，如果当前连接如果只能建立Http的连接，但是实际上需要连接到https，这个tunnel就是用来做这事的</span><br><span class="line">        if (route.requiresTunnel()) &#123;</span><br><span class="line">          connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener)</span><br><span class="line">          if (rawSocket &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; We were unable to connect the tunnel but properly closed down our resources.</span><br><span class="line">            break</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;创建一个socket</span><br><span class="line">          connectSocket(connectTimeout, readTimeout, call, eventListener)</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;建立一个协议的连接</span><br><span class="line">        establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener)</span><br><span class="line">        eventListener.connectEnd(call, route.socketAddress, route.proxy, protocol)</span><br><span class="line">        break</span><br><span class="line">      &#125; catch (e: IOException) &#123;</span><br><span class="line">        &#x2F;&#x2F;省略部分代码...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (route.requiresTunnel() &amp;&amp; rawSocket &#x3D;&#x3D; null) &#123;</span><br><span class="line">      throw RouteException(ProtocolException(</span><br><span class="line">          &quot;Too many tunnel connections attempted: $MAX_TUNNEL_ATTEMPTS&quot;))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    idleAtNs &#x3D; System.nanoTime()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="9、RealConnection-connectTunnel-："><a href="#9、RealConnection-connectTunnel-：" class="headerlink" title="9、RealConnection#connectTunnel()："></a>9、RealConnection#connectTunnel()：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private fun connectTunnel(</span><br><span class="line">  connectTimeout: Int,</span><br><span class="line">  readTimeout: Int,</span><br><span class="line">  writeTimeout: Int,</span><br><span class="line">  call: Call,</span><br><span class="line">  eventListener: EventListener</span><br><span class="line">) &#123;</span><br><span class="line">  var tunnelRequest: Request &#x3D; createTunnelRequest()</span><br><span class="line">  val url &#x3D; tunnelRequest.url</span><br><span class="line">  for (i in 0 until MAX_TUNNEL_ATTEMPTS) &#123;</span><br><span class="line">  &#x2F;&#x2F;先创建一个Socket</span><br><span class="line">    connectSocket(connectTimeout, readTimeout, call, eventListener)</span><br><span class="line">    &#x2F;&#x2F;创建一个tunnel请求</span><br><span class="line">    tunnelRequest &#x3D; createTunnel(readTimeout, writeTimeout, tunnelRequest, url)</span><br><span class="line">        ?: break &#x2F;&#x2F; Tunnel successfully created.</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; The proxy decided to close the connection after an auth challenge. We need to create a new</span><br><span class="line">    &#x2F;&#x2F; connection, but this time with the auth credentials.</span><br><span class="line">    rawSocket?.closeQuietly()</span><br><span class="line">    rawSocket &#x3D; null</span><br><span class="line">    sink &#x3D; null</span><br><span class="line">    source &#x3D; null</span><br><span class="line">    eventListener.connectEnd(call, route.socketAddress, route.proxy, null)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10、RealConnection-createTunnelRequest-："><a href="#10、RealConnection-createTunnelRequest-：" class="headerlink" title="10、RealConnection#createTunnelRequest()："></a>10、RealConnection#createTunnelRequest()：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private fun createTunnelRequest(): Request &#123;</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">  val proxyConnectRequest &#x3D; Request.Builder()</span><br><span class="line">      .url(route.address.url)</span><br><span class="line">      .method(&quot;CONNECT&quot;, null)&#x2F;&#x2F;发创建一个CONNECT的请求</span><br><span class="line">      .header(&quot;Host&quot;, route.address.url.toHostHeader(includeDefaultPort &#x3D; true))</span><br><span class="line">      .header(&quot;Proxy-Connection&quot;, &quot;Keep-Alive&quot;) &#x2F;&#x2F; For HTTP&#x2F;1.0 proxies like Squid.</span><br><span class="line">      .header(&quot;User-Agent&quot;, userAgent)</span><br><span class="line">      .build()</span><br><span class="line"></span><br><span class="line">  val fakeAuthChallengeResponse &#x3D; Response.Builder()</span><br><span class="line">      .request(proxyConnectRequest)</span><br><span class="line">      .protocol(Protocol.HTTP_1_1)</span><br><span class="line">      .code(HTTP_PROXY_AUTH)</span><br><span class="line">      .message(&quot;Preemptive Authenticate&quot;)</span><br><span class="line">      .body(EMPTY_RESPONSE)</span><br><span class="line">      .sentRequestAtMillis(-1L)</span><br><span class="line">      .receivedResponseAtMillis(-1L)</span><br><span class="line">      .header(&quot;Proxy-Authenticate&quot;, &quot;OkHttp-Preemptive&quot;)</span><br><span class="line">      .build()</span><br><span class="line"></span><br><span class="line">  val authenticatedRequest &#x3D; route.address.proxyAuthenticator</span><br><span class="line">      .authenticate(route, fakeAuthChallengeResponse)</span><br><span class="line"></span><br><span class="line">  return authenticatedRequest ?: proxyConnectRequest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11、RealConnection-establishProtocol-："><a href="#11、RealConnection-establishProtocol-：" class="headerlink" title="11、RealConnection#establishProtocol()："></a>11、RealConnection#establishProtocol()：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> private fun establishProtocol(</span><br><span class="line">   connectionSpecSelector: ConnectionSpecSelector,</span><br><span class="line">   pingIntervalMillis: Int,</span><br><span class="line">   call: Call,</span><br><span class="line">   eventListener: EventListener</span><br><span class="line"> ) &#123;</span><br><span class="line">   if (route.address.sslSocketFactory &#x3D;&#x3D; null) &#123;</span><br><span class="line">   &#x2F;&#x2F;如果是明文连接，Http2和Http1的连接建立的连接不同</span><br><span class="line">     if (Protocol.H2_PRIOR_KNOWLEDGE in route.address.protocols) &#123;</span><br><span class="line">       socket &#x3D; rawSocket</span><br><span class="line">       protocol &#x3D; Protocol.H2_PRIOR_KNOWLEDGE</span><br><span class="line">       startHttp2(pingIntervalMillis)</span><br><span class="line">       return</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     socket &#x3D; rawSocket</span><br><span class="line">     protocol &#x3D; Protocol.HTTP_1_1</span><br><span class="line">     return</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F;否则的话就是Https的连接</span><br><span class="line">   eventListener.secureConnectStart(call)</span><br><span class="line">   &#x2F;&#x2F;开始https的的握手过程</span><br><span class="line">   connectTls(connectionSpecSelector)</span><br><span class="line">   eventListener.secureConnectEnd(call, handshake)</span><br><span class="line"></span><br><span class="line">   if (protocol &#x3D;&#x3D;&#x3D; Protocol.HTTP_2) &#123;</span><br><span class="line">     startHttp2(pingIntervalMillis)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：这个拦截器最终会返回一个可用的连接，这个连接可能是连接池当中存在的，也可能是新创建的，在连接池的查找过程当中会有5次查找，首次进入的时候会查找一个不带代理服务器<br>不带多路复用的，如果没找到会再次从连接池当中查找一个带代理服务器，而不带多路复用的，如果还没找到就会新建一个连接，在新建立了连接之后，会在一个synchronized当中去查找<br>看创建的连接有没有存在多路复用的，存在则将后面一个创建的关闭，然后将创建的这个连接添加到连接池中以供下次使用。</p>
<p>CallServerInterceptor这个拦截器就是拿着ConnectInterceptor当中拿到的codec进行各种请求头和请求体的发送</p>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>第三方源码</tag>
        <tag>OkHttp</tag>
      </tags>
  </entry>
  <entry>
    <title>git核心概念</title>
    <url>/2017/03/31/git%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="一、中央式与分布式区别："><a href="#一、中央式与分布式区别：" class="headerlink" title="一、中央式与分布式区别："></a>一、中央式与分布式区别：</h1><p>​    分布式：例如：我们在远端将远端的某个数据进行删除之后，我们在本地通过git pull<br>​           拉取远端数据时，再通过本地去查看历史记录是可以看到远端的操作记录的，而且我们可以在本地重新恢复。每一个本地的都可以作为一个中央式的，当没有联网<br>​           的情况下，本地可以有多个提交，当有网络时再提交到远端，提交到远端会保持着所有在没有联网的情况下的提交，方便我们查看提交记录和代码评审<br>​    中央式：只有中央服务器保持着最新的版本，相同的场景，如果在没有联网的情况下去写代码，提交代码，当需要提交代码时，必须要联网才行。</p>
<a id="more"></a>

<h1 id="二、指令："><a href="#二、指令：" class="headerlink" title="二、指令："></a>二、指令：</h1><h2 id="git-clone："><a href="#git-clone：" class="headerlink" title="git clone："></a>git clone：</h2><p>​    在远端建立一个仓库，通过git clone 将远端仓库克隆到本地。</p>
<h2 id="git-log："><a href="#git-log：" class="headerlink" title="git log："></a>git log：</h2><p>​    查看提交记录</p>
<h2 id="git-add-："><a href="#git-add-：" class="headerlink" title="git add .："></a>git add .：</h2><p>​    将本地新增的文件添加进来</p>
<h2 id="git-commit："><a href="#git-commit：" class="headerlink" title="git commit："></a>git commit：</h2><p>​    更新内容说明</p>
<h2 id="git-push-origin-master："><a href="#git-push-origin-master：" class="headerlink" title="git push origin master："></a>git push origin master：</h2><p>​    将本地代码推到远端  origin是远端仓库 master是本地仓库的分支 如果远端没有这个仓库，那么会在远端创建一个新的仓库</p>
<h2 id="git-pull-origin-master"><a href="#git-pull-origin-master" class="headerlink" title="git pull origin master:"></a>git pull origin master:</h2><p>​    拉取远端内容</p>
<h2 id="git-branch-xxx"><a href="#git-branch-xxx" class="headerlink" title="git branch xxx:"></a>git branch xxx:</h2><p>​    创建一个分支</p>
<h2 id="git-checkout-xxx"><a href="#git-checkout-xxx" class="headerlink" title="git checkout xxx:"></a>git checkout xxx:</h2><p>​    这个xxx可以是某个hash、也可以是某个分支</p>
<h2 id="git-checkout-–detach"><a href="#git-checkout-–detach" class="headerlink" title="git checkout –detach"></a>git checkout –detach</h2><p>   直接与当前分支脱钩，指向当前commit</p>
<p>​    将HEAD指向某个分支，切换分支</p>
<h2 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge:"></a>git merge:</h2><p>​    切换到需要合并其他分支的分支，将要合并的分支合并</p>
<h2 id="git-merge-xxx-–no-ff"><a href="#git-merge-xxx-–no-ff" class="headerlink" title="git merge xxx –no-ff:"></a>git merge xxx –no-ff:</h2><p>不会查看出来做个合并</p>
<h2 id="git-reset-–hard-cf62f5"><a href="#git-reset-–hard-cf62f5" class="headerlink" title="git reset –hard cf62f5:"></a>git reset –hard cf62f5:</h2><p>​    将HEAD重新移动到这个hash值的位置</p>
<h2 id="git-merge-–continue"><a href="#git-merge-–continue" class="headerlink" title="git merge –continue:"></a>git merge –continue:</h2><p>​    合并过程中出现冲突，解决完冲突之后需要继续合并，先git add 再git merge –continue</p>
<h2 id="git-status"><a href="#git-status" class="headerlink" title="git status:"></a>git status:</h2><p>​    查看文件内容修改</p>
<h2 id="git-branch-d"><a href="#git-branch-d" class="headerlink" title="git branch -d:"></a>git branch -d:</h2><p>​    删除分支</p>
<h2 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase:"></a>git rebase:</h2><p>​    将分支合并到当前分支，如果使用git merge会先将当前分支和将要合并的分支合成一个新的commit，再合并，提交记录并不是一根直线，当我们希望提交的记录是一根直线，就可以使用git rebase，<br>​    但是合并过来的commit并不是被合并分支上的commit，是将被合并分支上的commit复制了一份，实际上被合并上的分支还是存在的。</p>
<h2 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash:"></a>git stash:</h2><p>​    将当前修改提交到暂存区，例如：在某个分支上开发东西，只开发到一般，并没有完全完成某个功能，当前不需要commit，且现在需要切换分支时，可以通过git stash存到暂存区，当前分支的修改<br>​    会到最初开始这个功能之前，才能切换到其他分支</p>
<h2 id="git-stash-pop"><a href="#git-stash-pop" class="headerlink" title="git stash pop:"></a>git stash pop:</h2><p>​    当我们在一个分支上做完事，需要回到我们之前开发一部分的分支上，通过该命令将暂存的修改重新找回来</p>
<h2 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset:"></a>git reset:</h2><p>​    会带着当前分支一起移动，而git checkout会将当前分支留在原地，而移动的只是HEAD，默认情况下是不会删除掉修改内容的，当reset 到某个分支时，只会移动到当前分支的那个commit<br>​    –hard:会将之前的修改的内容删除</p>
<h2 id="git-commit-–amend"><a href="#git-commit-–amend" class="headerlink" title="git commit –amend:"></a>git commit –amend:</h2><p>​    只能修改最新的<br>​    假设当前最新的已经提交的写错了，可以通过这个修改最新修改，其实是将之前的commit复制了一个新的commit出来</p>
<h2 id="git-rebase-XXX-i"><a href="#git-rebase-XXX-i" class="headerlink" title="git rebase XXX -i:"></a>git rebase XXX -i:</h2><p>​    交互式的rebase<br>​    可以修改指定位置的commit,也可以删除某个commit</p>
<h2 id="git-rebase-–continue"><a href="#git-rebase-–continue" class="headerlink" title="git rebase –continue:"></a>git rebase –continue:</h2><p>​    远端的master是不能进行修改的。一旦push了，不能修改，只有进行新的修改再push到远端，但是如果一次push内容比较多，不记得哪些修改过了只能revert</p>
<h2 id="git-revert-xxx"><a href="#git-revert-xxx" class="headerlink" title="git revert xxx:"></a>git revert xxx:</h2><p>​    将提交进行撤销操作</p>
<h2 id="git-add-i"><a href="#git-add-i" class="headerlink" title="git add -i:"></a>git add -i:</h2><p>​    交互式的提交。将一个commit拆分成多个commit</p>
<h2 id="git-diff-–staged"><a href="#git-diff-–staged" class="headerlink" title="git diff –staged:"></a>git diff –staged:</h2><p>​    缓存区和工作区的差异</p>
<h2 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff:"></a>git diff:</h2><p>​    工作目录和之前的提交的差异</p>
<h2 id="git-show"><a href="#git-show" class="headerlink" title="git show:"></a>git show:</h2><p>​    查看commit的内容</p>
<h2 id="git-tag-xxx"><a href="#git-tag-xxx" class="headerlink" title="git tag xxx:"></a>git tag xxx:</h2><p>​    tag跟branch很像，但是tag不能指向某个branch，且tag创建之后不能被改变，也不能被HEAD所指向。比较适合做持久的标记</p>
<h2 id="git-cherry-pick"><a href="#git-cherry-pick" class="headerlink" title="git cherry-pick:"></a>git cherry-pick:</h2><p>将某些提交摘出来</p>
<p>git reflog:<br>不加参数可以查看HEAD经过了哪些<br>git reflog xxx:<br>加参数可以查看分支经过了哪些</p>
<h1 id="三、指令都发生了什么："><a href="#三、指令都发生了什么：" class="headerlink" title="三、指令都发生了什么："></a>三、指令都发生了什么：</h1><p>​    本地仓库其实就是我们.git文件夹下面的东西，git的所有操作都会存放到这个里面<br>​    git commit:<br>​    记录着所有的改动，将所有改动提交到了工作空间，更改了hash值，一般只要知道hash值的前8位就可以了<br>​    git add:<br>​    将文件提交到暂存区<br>​    git clone:<br>​    从远端地址拿到本地  clone就两个目的：<br>​    1、将所有的操作记录拿到本地<br>​        将远端分支拿到本地，将远端分支的镜像拿到本地(镜像：名字都带有origin且不能被HEAD所指向)<br>​        拿到这些引用之后，会去拿到具体内容，再拿到内容的上一级内容，这样整个clone过程就完成了<br>​    2、将所有文件拿到本地<br>​    git push:<br>​    将本地的提交和之前的所有提交推到远端仓库<br>​        先将当前的commit提交到远端，当从当前commit到之前的位置存在缺失时，会将缺失的一部分也推上去，然后将远端的HEAD更新，将本地的镜像也更新<br>​    git pull:<br>​    拉取远程分支代码<br>​      1、把所有远端镜像更新到本地  git fetch<br>​      2、将缺失的commit更新到本地 git merge origin/??? 将远端合并到本地<br>​    git fetch:<br>​    将远端镜像取过来</p>
<p>引用：</p>
<p>​    指向某个提交的指针<br>​    cf62f530e29eeb08b4ab3b2309ef953aaad0edf0 (HEAD -&gt; main, origin/main, origin/HEAD)：例如括号里面的这几个，都指向cf62f53这个hash<br>​    HEAD：这个指针永远指向的是当前工作空间<br>​    </p>
<h1 id="四、项目中的分支管理：feature-Branching"><a href="#四、项目中的分支管理：feature-Branching" class="headerlink" title="四、项目中的分支管理：feature Branching"></a>四、项目中的分支管理：feature Branching</h1><p>​    先假设一种情况，当我们在master上做一个新功能时，现在突然来了一个紧急任务，需要优先处理，如果我们没有分支管理，直接也在master上进行处理，现在我们新功能<br>​    也在这个分支上，紧急任务也在这个分支上，那么紧急任务只能等我们新功能开发完之后才能提交，这就造成了我们这个紧急任务没这么快得到处理，所以这就体现了分支<br>​    管理的重要性。<br>​    Feature Branching：<br>​    1、新开发功能，拉出一个新的分支进行开发<br>​    2、紧急任务的，也重新拉出一个分支来<br>​    前面拉出的分支都必须是从最开始的完整分支拉出来的分支，当一个分支开发完之后，切换到master，将这个分支合并到master</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
</search>
