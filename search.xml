<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>享元模式</title>
    <url>/2017/12/03/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h5 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h5><p>享元模式，共享缘数据，就是将会重复创建的相同对象装在一个大池子里，当需要使用的时候直接从池子当中去取，而不再创建新的对象。</p>
<a id="more"></a>

<p>使用场景：</p>
<p>​    1、系统中存在大量相似对象。</p>
<p>​    2、细粒度的对象都具备较接近的外部状态，而且内部状态与环境无关，也就是说对象没有特定身份。</p>
<p>​    3、需要缓冲池的场景。</p>
<h5 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h5><p>类图：</p>
<p><img src="image-20200806100016274.png" alt="image-20200806100016274"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Ticket ticket1 &#x3D; TicketFactory.getTicket(&quot;深圳&quot;, &quot;成都&quot;);</span><br><span class="line">        ticket1.showTicketInfo(&quot;特等座&quot;);</span><br><span class="line">        Ticket ticket2 &#x3D; TicketFactory.getTicket(&quot;深圳&quot;, &quot;成都&quot;);</span><br><span class="line">        ticket2.showTicketInfo(&quot;一等座&quot;);</span><br><span class="line">        Ticket ticket3 &#x3D; TicketFactory.getTicket(&quot;深圳&quot;, &quot;成都&quot;);</span><br><span class="line">        ticket3.showTicketInfo(&quot;二等座&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Ticket &#123;</span><br><span class="line">    public void showTicketInfo(String seating);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TrainTicket implements Ticket &#123;</span><br><span class="line">    String from;</span><br><span class="line">    String to;</span><br><span class="line">    int price;</span><br><span class="line">    String seating;</span><br><span class="line"></span><br><span class="line">    public TrainTicket(String from, String to) &#123;</span><br><span class="line">        this.from &#x3D; from;</span><br><span class="line">        this.to &#x3D; to;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void showTicketInfo(String seating) &#123;</span><br><span class="line">        price &#x3D; new Random().nextInt(800);</span><br><span class="line">        System.out.println(&quot;购买从&quot; + from + &quot;到&quot; + to + &quot;的&quot; + seating + &quot;火车票，&quot; + &quot;票价：&quot; + price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TicketFactory &#123;</span><br><span class="line">    static ConcurrentHashMap&lt;String, Ticket&gt; ticketMap &#x3D; new ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public static Ticket getTicket(String from, String to) &#123;</span><br><span class="line">        String key &#x3D; from + &quot;-&quot; + to;</span><br><span class="line">        if (ticketMap.containsKey(key)) &#123;</span><br><span class="line">            System.out.println(&quot;使用类缓存池中的对象&quot;);</span><br><span class="line">            return ticketMap.get(key);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;创建类了新的对象&quot;);</span><br><span class="line">            TrainTicket trainTicket &#x3D; new TrainTicket(from, to);</span><br><span class="line">            ticketMap.put(key, trainTicket);</span><br><span class="line">            return trainTicket;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>享元模式，避免了重复的类似对象的创建，大大节省了内存开销，尤其是一些大的对象，在对象池当中会去维护一个key或者一个状态，当在集合中key存在或者状态为可重用状态时则直接返回对象池中的对象，否则创建新的对象。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>代理模式</title>
    <url>/2017/11/19/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h5 id="1、静态代理："><a href="#1、静态代理：" class="headerlink" title="1、静态代理："></a>1、静态代理：</h5><h6 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h6><p>代理模式又称为委托模式，为其他对象提供代理来控制对这个对象的访问。    </p>
<a id="more"></a>

<h6 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h6><p>类图：</p>
<p><img src="image-20200807145228102.png" alt="image-20200807145228102"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 静态代理</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new LogTankProxy(new TimeTankProxy(new Tank())).move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Movable&#123;</span><br><span class="line">    void move();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Tank implements Movable&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void move() &#123;</span><br><span class="line">        System.out.println(&quot;坦克...kakaka的跑&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class LogTankProxy implements Movable&#123;</span><br><span class="line">    private Movable tank;</span><br><span class="line"></span><br><span class="line">    public LogTankProxy(Movable tank) &#123;</span><br><span class="line">        this.tank &#x3D; tank;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void move() &#123;</span><br><span class="line">        System.out.println(&quot;坦克开启来来...&quot;);</span><br><span class="line">        tank.move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TimeTankProxy implements Movable&#123;</span><br><span class="line">    private Tank tank;</span><br><span class="line"></span><br><span class="line">    public TimeTankProxy(Tank tank) &#123;</span><br><span class="line">        this.tank &#x3D; tank;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void move() &#123;</span><br><span class="line">        long startTime &#x3D; System.currentTimeMillis();</span><br><span class="line">        tank.move();</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(new Random().nextInt(10000));</span><br><span class="line">            long endTime &#x3D; System.currentTimeMillis();</span><br><span class="line">            System.out.println((endTime-startTime)&#x2F;1000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>静态代理每个代理当中聚合了一个被代理对象，类似装饰器模式，但是静态代理只能代理我们清楚代理的方法。所以就有了动态代理。</p>
<h5 id="2、动态代理："><a href="#2、动态代理：" class="headerlink" title="2、动态代理："></a>2、动态代理：</h5><h6 id="概念：-1"><a href="#概念：-1" class="headerlink" title="概念："></a>概念：</h6><p>​    通过二进制字节码分析类的属性和方法。</p>
<h6 id="案例：-1"><a href="#案例：-1" class="headerlink" title="案例："></a>案例：</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Tank tank &#x3D; new Tank();</span><br><span class="line">        System.getProperties().put(&quot;jdk.proxy.ProxyGenerator.saveGeneratedFiles&quot;,&quot;true&quot;);</span><br><span class="line">        Movable m &#x3D; (Movable) Proxy.newProxyInstance(Tank.class.getClassLoader(),&#x2F;&#x2F;需要用到的classLoader</span><br><span class="line">                new Class[]&#123;Movable.class&#125;, &#x2F;&#x2F;动态生成的类需要实现的接口</span><br><span class="line">                new InvocationHandler() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">                System.out.println(&quot;method &quot;+method.getName()+&quot; start..&quot;);</span><br><span class="line">                Object o &#x3D; method.invoke(tank, args);</span><br><span class="line">                System.out.println(&quot;method &quot;+method.getName()+&quot; end&quot;);</span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        m.move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Movable&#123;</span><br><span class="line">    void move();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Tank implements Movable&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void move() &#123;</span><br><span class="line">        System.out.println(&quot;tank moving ....&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(new Random().nextInt(10000));</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h6><p>​    jdk的动态代理，必须要指定接口，只有指定了接口才知道要生成哪些方法。为解决jdk当中的这种情况，可以通过cglib实现动态代理，但是如果被代理类时final类型的，那么就只能通过asm来实现代理。</p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2017/11/17/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="单例模式-Sigleton-："><a href="#单例模式-Sigleton-：" class="headerlink" title="单例模式(Sigleton)："></a>单例模式(Sigleton)：</h2><h5 id="概念及应用"><a href="#概念及应用" class="headerlink" title="概念及应用"></a>概念及应用</h5><p>​    在内存中只允许一个实例对象，比如：各种Manager、各种Factory。</p>
<a id="more"></a>

<h5 id="实现方法：8种"><a href="#实现方法：8种" class="headerlink" title="实现方法：8种"></a>实现方法：8种</h5><h6 id="1-饿汉式："><a href="#1-饿汉式：" class="headerlink" title="1.饿汉式："></a>1.饿汉式：</h6><p>当类被加载到内存时就实例话对象，因为是static的，因此JVM可以保证线程安全（推荐使用）</p>
<p>缺点：不管是否使用，只要被加载到内存就会实例化对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Mgr01 &#123;</span><br><span class="line">    private static final Mgr01 INSTANCE &#x3D; new Mgr01();</span><br><span class="line">    private Mgr01()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Mgr01 getInstance()&#123;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="2-饿汉式等价写法："><a href="#2-饿汉式等价写法：" class="headerlink" title="2.饿汉式等价写法："></a>2.饿汉式等价写法：</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Mgr02 &#123;</span><br><span class="line">    private static Mgr02 INSTANCE ;</span><br><span class="line">    static &#123;</span><br><span class="line">        INSTANCE &#x3D; new Mgr02();</span><br><span class="line">    &#125;</span><br><span class="line">    private Mgr02()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Mgr02 getInstance()&#123;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="3-懒汉式："><a href="#3-懒汉式：" class="headerlink" title="3.懒汉式："></a>3.懒汉式：</h6><p>为了弥补前面饿汉式当中被加载进内存就初始化的问题，这里通过懒汉式的方式进行加载。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Mgr03 &#123;</span><br><span class="line">    private static Mgr03 INSTANCE;</span><br><span class="line">    private Mgr03()&#123;&#125;</span><br><span class="line">    public static Mgr03 getInstance()&#123;</span><br><span class="line">        if(INSTANCE &#x3D;&#x3D; null)&#123;</span><br><span class="line">            INSTANCE &#x3D; new Mgr03();</span><br><span class="line">        &#125;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点：这种懒汉式的方法会在多线程的情况下不能保证内存中只有一个实例</p>
<h6 id="4-懒汉式-方法上加锁"><a href="#4-懒汉式-方法上加锁" class="headerlink" title="4.懒汉式(方法上加锁):"></a>4.懒汉式(方法上加锁):</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Mgr04 &#123;</span><br><span class="line">    private static Mgr04 INSTANCE;</span><br><span class="line"></span><br><span class="line">    private Mgr04() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static synchronized Mgr04 getInstance() &#123;</span><br><span class="line">        if (INSTANCE &#x3D;&#x3D; null) &#123;</span><br><span class="line">            INSTANCE &#x3D; new Mgr04();</span><br><span class="line">        &#125;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点：方法上加锁，在多线程的情况下，每次都要判断锁，导致性能下降。</p>
<h6 id="5-懒汉式-作用域-："><a href="#5-懒汉式-作用域-：" class="headerlink" title="5.懒汉式(作用域)："></a>5.懒汉式(作用域)：</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Mgr05 &#123;</span><br><span class="line"></span><br><span class="line">    private static Mgr05 INSTANCE;</span><br><span class="line"></span><br><span class="line">    private Mgr05() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Mgr05 getInstance() &#123;</span><br><span class="line">        if (INSTANCE &#x3D;&#x3D; null) &#123;</span><br><span class="line">            synchronized (Mgr05.class) &#123;</span><br><span class="line">                INSTANCE &#x3D; new Mgr05();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点：上面这种直接减小同步代码块的作用域在多线程的情况下并不能保证单一实例。</p>
<h6 id="6-懒汉式-双重判断-："><a href="#6-懒汉式-双重判断-：" class="headerlink" title="6.懒汉式(双重判断)："></a>6.懒汉式(双重判断)：</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Mgr06 &#123;</span><br><span class="line"></span><br><span class="line">    private static volatile Mgr06 INSTANCE;</span><br><span class="line"></span><br><span class="line">    private Mgr06() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Mgr06 getInstance() &#123;</span><br><span class="line">        if (INSTANCE &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;判断是否加锁</span><br><span class="line">            synchronized (Mgr06.class) &#123;</span><br><span class="line">                if (INSTANCE &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;判断对象是否实例化</span><br><span class="line">                    INSTANCE &#x3D; new Mgr06();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="7-静态内部类："><a href="#7-静态内部类：" class="headerlink" title="7.静态内部类："></a>7.静态内部类：</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Mgr07 &#123;</span><br><span class="line">    private static class Mgr07Holder&#123;</span><br><span class="line">        private static final Mgr07 INSTANCE &#x3D; new Mgr07();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Mgr07()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Mgr07 getInstance()&#123;</span><br><span class="line">        return Mgr07Holder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：当类被加载到内存时并不会直接实例化对象，达到了懒汉式的效果，同时JVM保证了多线程安全问题。</p>
<h6 id="8-枚举方式："><a href="#8-枚举方式：" class="headerlink" title="8. 枚举方式："></a>8. 枚举方式：</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum  Mgr08 &#123;</span><br><span class="line">    INSTANCE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>保证实例单一的同时还可以防止被反序列化。前面的其他方式都可以通过反射的方式创建多个实例。枚举类不会被反序列化的原因是因为枚举不存在构造函数，所以不能实例化。</p>
<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>单例模式就是为了保证在内存中实例的唯一性，通常我们写单例模式比较完美的写法：饿汉式、双重判断+锁+volatile的懒汉式、静态内部类、枚举方式。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>六大设计原则</title>
    <url>/2017/11/10/%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h5 id="1、单一职责-："><a href="#1、单一职责-：" class="headerlink" title="1、单一职责 ："></a>1、单一职责 ：</h5><p>​        就一个类而言，应该仅有一个引起他变化的原因，一个类应该是一组相关性很高的函数、数据的封装</p>
<h5 id="2、开闭原则："><a href="#2、开闭原则：" class="headerlink" title="2、开闭原则："></a>2、开闭原则：</h5><p>​        软件中的对象对于扩展是开放的，对于修改应该是关闭的</p>
<a id="more"></a>

<h5 id="3、里氏替换原则"><a href="#3、里氏替换原则" class="headerlink" title="3、里氏替换原则"></a>3、里氏替换原则</h5><p>​        任何父类出现的地方都可以被子类替换。</p>
<h5 id="4、依赖倒置原则："><a href="#4、依赖倒置原则：" class="headerlink" title="4、依赖倒置原则："></a>4、依赖倒置原则：</h5><p>​        模块之间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或者抽象类产生的。</p>
<h5 id="5、接口隔离原则："><a href="#5、接口隔离原则：" class="headerlink" title="5、接口隔离原则："></a>5、接口隔离原则：</h5><p>​        客户端不需要依赖他不需要的接口，类间的依赖关系应该建立在最小的接口上</p>
<h5 id="6、迪米特法则："><a href="#6、迪米特法则：" class="headerlink" title="6、迪米特法则："></a>6、迪米特法则：</h5><p>​        一个对象应该对其他对象有最少的了解</p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂模式</title>
    <url>/2017/11/25/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h5 id="概念及应用"><a href="#概念及应用" class="headerlink" title="概念及应用:"></a>概念及应用:</h5><p>任何可以产生对象的方法或类，都可以称为工厂</p>
<h5 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h5><h6 id="1、工厂方法-Factory-method-："><a href="#1、工厂方法-Factory-method-：" class="headerlink" title="1、工厂方法(Factory method)："></a>1、工厂方法(Factory method)：</h6><p>​        概念：简单工厂就是对于不同产品都有自己的工厂方法创建相应的实例对象。</p>
<a id="more"></a>

<p>​        案例：</p>
<p>​        类图：</p>
<p><img src="image-20200803105430375.png" alt="image-20200803105430375"></p>
<p>Moveable：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Moveable &#123;</span><br><span class="line">    void go();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        Car：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Car implements Moveable&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void go()&#123;</span><br><span class="line">        System.out.println(&quot;Car go ....&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        plane：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Plane implements Moveable&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void go()&#123;</span><br><span class="line">        System.out.println(&quot;sou sou sou ....&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>工厂类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SimpleVehicleFactory &#123;</span><br><span class="line">    public Car createCar()&#123;</span><br><span class="line">        return new Car();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Plane createPlane()&#123;</span><br><span class="line">        return new Plane();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Broom createBroom()&#123;</span><br><span class="line">        return new Broom();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SimpleVehicleFactory simpleVehicleFactory &#x3D; new SimpleVehicleFactory();</span><br><span class="line">        simpleVehicleFactory.createCar().go();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2、抽象工厂-abstractFactory-："><a href="#2、抽象工厂-abstractFactory-：" class="headerlink" title="2、抽象工厂(abstractFactory)："></a>2、抽象工厂(abstractFactory)：</h6><p>​    概念：能创建一个产品族。工厂抽象，不同的产品族对应不同的工厂实现，产品抽象，具体的产品各自实现。</p>
<p>类图：</p>
<p><img src="%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/image-20200803111056423.png" alt="image-20200803111056423"></p>
<p>​    </p>
<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>工厂方法模式对于产品的扩展是很方便的，只需要添加产品和产品工厂即可。但是如果是一个产品族的扩展，抽象工厂模式比较容易扩展。</p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>建造者模式</title>
    <url>/2017/12/01/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="建造者模式-Builder"><a href="#建造者模式-Builder" class="headerlink" title="建造者模式(Builder):"></a>建造者模式(Builder):</h2><h5 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h5><h5 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private Person()&#123;&#125;</span><br><span class="line">    int id;</span><br><span class="line">    int age;</span><br><span class="line">    String name;</span><br><span class="line">    double weight;</span><br><span class="line">    int score;</span><br><span class="line">    Location loc;</span><br><span class="line">    </span><br><span class="line">    public static class PersonBuilder&#123;</span><br><span class="line">        private Person p &#x3D; new Person();</span><br><span class="line">        public PersonBuilder basicInfo(int id,String name,int age)&#123;</span><br><span class="line">            p.id &#x3D; id;</span><br><span class="line">            p.name &#x3D; name;</span><br><span class="line">            p.age &#x3D; age;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        public PersonBuilder weight(double weight)&#123;</span><br><span class="line">            p.weight &#x3D; weight;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        public PersonBuilder score(int score)&#123;</span><br><span class="line">            p.score &#x3D; score;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        public PersonBuilder loc(String street,String roomNo)&#123;</span><br><span class="line">            p.loc &#x3D; new Location(street,roomNo);</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        public Person build()&#123;</span><br><span class="line">            return p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Location&#123;</span><br><span class="line">    String street;</span><br><span class="line">    String roomNo;</span><br><span class="line"></span><br><span class="line">    public Location(String street, String roomNo) &#123;</span><br><span class="line">        this.street &#x3D; street;</span><br><span class="line">        this.roomNo &#x3D; roomNo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>builder模式就是在需要被创建出的对象中提供静态内部类，在内部类当中创建实例，提供为每个属性赋值的方法，并返回静态内部类，最后在静态内部类当中提供build()，返回需要创建的对象即可。</p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>桥接模式</title>
    <url>/2017/12/02/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h5 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h5><p>抽象与具体之间分开发展，抽象当中聚合具体的实现，相互之间不容易产生类爆炸情况。</p>
<a id="more"></a>

<h5 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h5><p>类图</p>
<p><img src="image-20200826103756075.png" alt="image-20200826103756075"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Gift &#123;</span><br><span class="line">    GiftImpl giftImpl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class GiftImpl &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class WarmGift extends Gift&#123;</span><br><span class="line">    public WarmGift(GiftImpl giftImpl)&#123;</span><br><span class="line">        this.giftImpl &#x3D; giftImpl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ColdGift extends Gift&#123;</span><br><span class="line">    public ColdGift(GiftImpl giftImpl) &#123;</span><br><span class="line">        this.giftImpl &#x3D; giftImpl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Flower extends GiftImpl&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Book extends GiftImpl&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class GG &#123;</span><br><span class="line">    public void chase()&#123;</span><br><span class="line">        ColdGift coldGift &#x3D; new ColdGift(new Flower());</span><br><span class="line">        give(new MM(),coldGift);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void give(MM mm,Gift gift)&#123;</span><br><span class="line">        System.out.println(gift+&quot;gived!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MM &#123;</span><br><span class="line">    String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>如果一个场景，抽象的类别也在不断的扩展，具体的也在不断的扩展，可以用桥接模式。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>模版方法模式</title>
    <url>/2017/11/17/%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h5 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h5><p>模版方法其实就是钩子函数，父类中的方法定义了调用一些方法的调用步骤，这些步骤又延迟到子类中去实现。</p>
<a id="more"></a>

<h5 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        F f &#x3D; new C();</span><br><span class="line">        f.m();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">abstract class F&#123;</span><br><span class="line">    void m()&#123;</span><br><span class="line">        op1();</span><br><span class="line">        op2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    abstract void op1();</span><br><span class="line">    abstract void op2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C extends F&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void op1() &#123;</span><br><span class="line">        System.out.println(&quot;op1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void op2() &#123;</span><br><span class="line">        System.out.println(&quot;op2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>模版方法就是在类中定义了方法的执行顺序，但是这些方法额具体实现在子类中。钩子函数也是模版方法。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>策略模式</title>
    <url>/2017/11/18/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="策略模式-Strategy-："><a href="#策略模式-Strategy-：" class="headerlink" title="策略模式(Strategy)："></a>策略模式(Strategy)：</h2><h5 id="概念及应用"><a href="#概念及应用" class="headerlink" title="概念及应用:"></a>概念及应用:</h5><p>定义了一系列算法，将每个算法封装起来，做一件事可以采用不同的方式。    Android动画中的插值器。</p>
<a id="more"></a>

<h5 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h5><p>   类图：<img src="image-20200803112833812.png" alt="image-20200803112833812"></p>
<p>Sorter:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Sorter&lt;T&gt; &#123;</span><br><span class="line">    public void sort(T[] arr, Comparator&lt;T&gt; comparator) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line">            int minPos &#x3D; i;</span><br><span class="line">            for (int j &#x3D; i + 1; j &lt; arr.length; j++) &#123;</span><br><span class="line">                minPos &#x3D; comparator.compare(arr[j], arr[minPos]) &#x3D;&#x3D; -1 ? j : minPos;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            swap(arr, i, minPos);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void swap(T[] arr, int i, int j) &#123;</span><br><span class="line">        T temp &#x3D; arr[i];</span><br><span class="line">        arr[i] &#x3D; arr[j];</span><br><span class="line">        arr[j] &#x3D; temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Comparator:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Comparator&lt;T&gt; &#123;</span><br><span class="line">    int compare(T t1,T t2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CatWeightComparator:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CatWeightComparator implements Comparator&lt;Cat&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(Cat t1, Cat t2) &#123;</span><br><span class="line">        if (t1.weight &gt; t2.weight) return 1;</span><br><span class="line">        else if (t1.weight &lt; t2.weight) return -1;</span><br><span class="line">        else</span><br><span class="line">            return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CatHeightComparator:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CatHeightComparator implements Comparator&lt;Cat&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(Cat t1, Cat t2) &#123;</span><br><span class="line">        if (t1.height &lt; t2.height) return 1;</span><br><span class="line">        else if (t1.height &#x3D;&#x3D; t2.height) return 0;</span><br><span class="line">        else return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DogWeightComparator:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class DogWeightComparator implements Comparator&lt;Dog&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(Dog t1, Dog t2) &#123;</span><br><span class="line">        if (t1.weight &gt; t2.weight) return 1;</span><br><span class="line">        else if (t1.weight &lt; t2.weight) return -1;</span><br><span class="line">        else</span><br><span class="line">            return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">&#x2F;&#x2F;        Cat[] cats &#x3D; &#123;new Cat(1,1),new Cat(3,3),new Cat(2,2)&#125;;</span><br><span class="line">&#x2F;&#x2F;        Sorter&lt;Cat&gt; sorter &#x3D; new Sorter&lt;&gt;();</span><br><span class="line">&#x2F;&#x2F;        sorter.sort(cats,new CatWeightComparator());</span><br><span class="line">&#x2F;&#x2F;        System.out.println(Arrays.toString(cats));</span><br><span class="line"></span><br><span class="line">        Dog[] dogs &#x3D; &#123;new Dog(2),new Dog(1),new Dog(4)&#125;;</span><br><span class="line">        Sorter&lt;Dog&gt; sorter1 &#x3D; new Sorter&lt;&gt;();</span><br><span class="line">        sorter1.sort(dogs,new DogWeightComparator());</span><br><span class="line">        System.out.println(Arrays.toString(dogs));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>所谓策略模式，封装的是做一件事的不同方式。</p>
<p>扩展：在1.8之后允许接口当中存在方法的实现，但是方法必须是default修饰，default关键字是为了兼容之前版本，实现类只需要实现abstract的方法，default的方法可以不被实现。</p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>组合模式</title>
    <url>/2017/12/12/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h5 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h5><p>​    就是一种树状结构，有叶子节点和分支，分支下面又有叶子节点和分支。</p>
<a id="more"></a>

<h5 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h5><p>类图：</p>
<p>​    <img src="image-20200806084442400.png" alt="image-20200806084442400"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BranchNode root &#x3D; new BranchNode(&quot;root&quot;);</span><br><span class="line">        BranchNode chapter1 &#x3D; new BranchNode(&quot;chapter1&quot;);</span><br><span class="line">        BranchNode chapter2 &#x3D; new BranchNode(&quot;chapter2&quot;);</span><br><span class="line"></span><br><span class="line">        Leaf c11 &#x3D; new Leaf(&quot;c11&quot;);</span><br><span class="line">        Leaf c12 &#x3D; new Leaf(&quot;c12&quot;);</span><br><span class="line"></span><br><span class="line">        BranchNode section21 &#x3D; new BranchNode(&quot;section21&quot;);</span><br><span class="line">        Leaf c211 &#x3D; new Leaf(&quot;c211&quot;);</span><br><span class="line">        Leaf c212 &#x3D; new Leaf(&quot;c212&quot;);</span><br><span class="line"></span><br><span class="line">        root.add(chapter1);</span><br><span class="line">        root.add(chapter2);</span><br><span class="line">        chapter1.add(c11);</span><br><span class="line">        chapter1.add(c12);</span><br><span class="line">        chapter2.add(section21);</span><br><span class="line">        section21.add(c211);</span><br><span class="line">        section21.add(c212);</span><br><span class="line"></span><br><span class="line">        tree(root,0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void tree(Node node,int depth)&#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; depth; i++) &#123;</span><br><span class="line">            System.out.print(&quot;--&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        node.print();</span><br><span class="line">        if(node instanceof BranchNode)&#123;</span><br><span class="line">            for(Node n :((BranchNode) node).nodes)&#123;</span><br><span class="line">                tree(n,depth+1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract class Node &#123;</span><br><span class="line">    abstract void print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Leaf extends Node&#123;</span><br><span class="line">    private String content;</span><br><span class="line">    public Leaf(String content)&#123;</span><br><span class="line">        this.content &#x3D; content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void print() &#123;</span><br><span class="line">        System.out.println(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BranchNode extends Node&#123;</span><br><span class="line">    public List&lt;Node&gt; nodes &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    public BranchNode(String name)&#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    void print() &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void add(Node node)&#123;</span><br><span class="line">        nodes.add(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>组合模式就是一个树状结构，里面可以有叶子节点和分支节点，分支节点当中又可以有分支节点和叶子节点，可以无穷下去。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>装饰器模式</title>
    <url>/2017/12/10/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h5 id="概念及应用场景："><a href="#概念及应用场景：" class="headerlink" title="概念及应用场景："></a>概念及应用场景：</h5><p>动态给一个对象添加额外的职责，从增加功能的角度说，新增加功能比生成子类更加灵活。</p>
<a id="more"></a>

<h5 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h5><p>类图：<img src="image-20200803174118003.png" alt="image-20200803174118003"></p>
<p>具体实现：</p>
<p>​    组件抽象类Component：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class Component &#123;</span><br><span class="line">    abstract void operate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    组件具体实现ConcreteComponent：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ConcreteComponent extends Component&#123;</span><br><span class="line">    @Override</span><br><span class="line">    void operate() &#123;</span><br><span class="line">        &#x2F;&#x2F;具体逻辑</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    装饰者抽象类Decorator：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class Decorator extends Component&#123;</span><br><span class="line">    private Component component;</span><br><span class="line">    public Decorator(Component component)&#123;</span><br><span class="line">        this.component &#x3D; component;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    void operate() &#123;</span><br><span class="line">        component.operate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>装饰者具体实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ConcreteDecoratorA extends Decorator&#123;</span><br><span class="line">    public ConcreteDecoratorA(Component component) &#123;</span><br><span class="line">        super(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void operate() &#123;</span><br><span class="line">        operateA();</span><br><span class="line">        super.operate();</span><br><span class="line">        operateB();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void operateA() &#123;</span><br><span class="line">        &#x2F;&#x2F;装饰方法</span><br><span class="line">    &#125;</span><br><span class="line">    public void operateB() &#123;</span><br><span class="line">        &#x2F;&#x2F;装饰方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ConcreteDecoratorB extends Decorator&#123;</span><br><span class="line">    public ConcreteDecoratorB(Component component) &#123;</span><br><span class="line">        super(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void operate() &#123;</span><br><span class="line">        super.operate();</span><br><span class="line">        operateA();</span><br><span class="line">        operateB();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void operateA() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void operateB()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ConcreteComponent concreteComponent &#x3D; new ConcreteComponent();</span><br><span class="line">        ConcreteDecoratorA decorator &#x3D; new ConcreteDecoratorA(concreteComponent);</span><br><span class="line">        decorator.operate();</span><br><span class="line"></span><br><span class="line">        ConcreteDecoratorB decoratorB &#x3D; new ConcreteDecoratorB(concreteComponent);</span><br><span class="line">        decoratorB.operate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>所谓的装饰器模式是动态的为对象进行功能的增强，被装饰者与抽象的装饰者都继承自同一个抽象组件，抽象装饰者中动态传入了被装饰者，在装饰者的具体实现当中，原有的方法中又调用了增强功能的方法。Java中的流就是典型的装饰器模式</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>观察者模式</title>
    <url>/2017/11/26/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h5 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h5><p>定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，所有依赖于他的对象都会得到通知并自动更新。</p>
<h5 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h5><h5 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h5><p>类图：</p>
<p><img src="image-20200805144209128.png" alt="image-20200805144209128"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child&#123;</span><br><span class="line">    private List&lt;Observer&gt; observers &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    &#123;</span><br><span class="line">        observers.add(new Mom());</span><br><span class="line">        observers.add(new Dad());</span><br><span class="line">    &#125;</span><br><span class="line">    public void wakeUp()&#123;</span><br><span class="line">        WakeEvent wakeEvent &#x3D; new WakeEvent(System.currentTimeMillis(), &quot;bed&quot;, this);</span><br><span class="line">        for (Observer observer : observers) &#123;</span><br><span class="line">            observer.wakeUp(wakeEvent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class WakeEvent&#123;</span><br><span class="line">    long timeStamp;</span><br><span class="line">    String loc;</span><br><span class="line">    Child source;</span><br><span class="line"></span><br><span class="line">    public WakeEvent(long timeStamp,String loc,Child source)&#123;</span><br><span class="line">        this.timeStamp &#x3D; timeStamp;</span><br><span class="line">        this.loc &#x3D; loc;</span><br><span class="line">        this.source &#x3D; source;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Observer&#123;</span><br><span class="line">    void wakeUp(WakeEvent event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Mom implements Observer&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void wakeUp(WakeEvent event) &#123;</span><br><span class="line">        hug();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void hug() &#123;</span><br><span class="line">        System.out.println(&quot;mom hug...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dad implements Observer&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void wakeUp(WakeEvent event) &#123;</span><br><span class="line">        feed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void feed() &#123;</span><br><span class="line">        System.out.println(&quot;dad feed...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>被观察者中添加了所有的观察者，当被观察者发生变化的时候会遍历所有的观察者发生变化。所有的Observer、listener、hook method、Callback都是观察者模式。</p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>访问者模式</title>
    <url>/2017/11/23/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="访问者模式-Visitor"><a href="#访问者模式-Visitor" class="headerlink" title="访问者模式(Visitor):"></a>访问者模式(Visitor):</h2><h5 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h5><p>​    当内部固定，需要根据不同需求得到不同结果的时候使用。如果内部结构不固定，那么该设计模式就不合适。</p>
<a id="more"></a>

<h5 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h5><p>类图：</p>
<p><img src="image-20200809184953351.png" alt="image-20200809184953351"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Computer &#123;</span><br><span class="line">    ComputerPart cpu &#x3D; new Cpu();</span><br><span class="line">    ComputerPart memory &#x3D; new Memory();</span><br><span class="line">    ComputerPart keyBord &#x3D; new KeyBord();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        PersonnelVisitor personnelVisitor &#x3D; new PersonnelVisitor();</span><br><span class="line">        new Computer().accept(personnelVisitor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void accept(Visitor v) &#123;</span><br><span class="line">        cpu.accept(v);</span><br><span class="line">        memory.accept(v);</span><br><span class="line">        keyBord.accept(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    abstract class ComputerPart &#123;</span><br><span class="line">        abstract void accept(Visitor v);</span><br><span class="line"></span><br><span class="line">        abstract double getPrice();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    interface Visitor &#123;</span><br><span class="line">        void visitCpu(ComputerPart cpu);</span><br><span class="line"></span><br><span class="line">        void visitMemory(ComputerPart memory);</span><br><span class="line"></span><br><span class="line">        void visitKeyBord(ComputerPart keyBord);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Cpu extends ComputerPart &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        void accept(Visitor v) &#123;</span><br><span class="line">            v.visitCpu(this);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        double getPrice() &#123;</span><br><span class="line">            return 300;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class KeyBord extends ComputerPart &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        void accept(Visitor v) &#123;</span><br><span class="line">            v.visitKeyBord(this);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        double getPrice() &#123;</span><br><span class="line">            return 100;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Memory extends ComputerPart &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        void accept(Visitor v) &#123;</span><br><span class="line">            v.visitMemory(this);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        double getPrice() &#123;</span><br><span class="line">            return 200;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class PersonnelVisitor implements Visitor &#123;</span><br><span class="line">        double totalPrice;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void visitCpu(ComputerPart cpu) &#123;</span><br><span class="line">            totalPrice +&#x3D; cpu.getPrice() * .6f;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void visitMemory(ComputerPart memory) &#123;</span><br><span class="line">            totalPrice +&#x3D; memory.getPrice() * .5f;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void visitKeyBord(ComputerPart keyBord) &#123;</span><br><span class="line">            totalPrice +&#x3D; keyBord.getPrice() * .7f;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class CropVisitor implements Visitor &#123;</span><br><span class="line">        double totalPrice;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void visitCpu(ComputerPart cpu) &#123;</span><br><span class="line">            totalPrice +&#x3D; cpu.getPrice() * .9f;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void visitMemory(ComputerPart memory) &#123;</span><br><span class="line">            totalPrice +&#x3D; memory.getPrice() * .9f;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void visitKeyBord(ComputerPart keyBord) &#123;</span><br><span class="line">            totalPrice +&#x3D; keyBord.getPrice() * .9f;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>访问者模式只适用于当内部结构固定的情况下使用，如果内部结构经常发生变化，则不适合使用。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>责任链模式</title>
    <url>/2017/12/05/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h5 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h5><p>Chain Of Responsibility,最普通的责任链就是每个可处理的过滤器都可以对原始数据做处理，多个链条也可以直接进行连接。但最完善的责任链模式则是需要对请求和响应进行处理，每个链上的对象都可以终止请求或者响应。</p>
<a id="more"></a>

<h5 id="实现方式及案例："><a href="#实现方式及案例：" class="headerlink" title="实现方式及案例："></a>实现方式及案例：</h5><p>在我们的案例中我们需要满足，当一个request执行完成之后，满足条件就继续下一次request处理，当所有的request执行完成之后，需要将response倒过来执行，即后添加的response需要先执行。</p>
<p>那么在实现的过程中，我们可以在每个Filter当中都传入我们的chain引用，当每个filter满足条件时选择是否要执行chain的doFilter()，在FilterChain中需要对当前执行到那个Filter进行位置记录，方便下次调用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ServletMain &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Request request &#x3D; new Request();</span><br><span class="line">        request.str &#x3D; &quot;大家好:),&lt;script&gt;欢迎访问我的个人网站：roqy.com，大家都是996&quot;;</span><br><span class="line"></span><br><span class="line">        Response response &#x3D; new Response();</span><br><span class="line">        response.str &#x3D; &quot;response&quot;;</span><br><span class="line">        FilterChain chain &#x3D; new FilterChain();</span><br><span class="line">        chain.add(new FaceFilter())</span><br><span class="line">                .add(new HTMLFilter())</span><br><span class="line">                .add(new HttpFilter())</span><br><span class="line">                .doFilter(request,response);</span><br><span class="line">        System.out.println(request.str);</span><br><span class="line">        System.out.println(response.str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Request &#123;</span><br><span class="line">    String str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Response &#123;</span><br><span class="line">    String str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Filter &#123;</span><br><span class="line">    void doFilter(Request request, Response response, FilterChain chain);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class FilterChain&#123;</span><br><span class="line">    int index &#x3D; 0;&#x2F;&#x2F;记录当前调用到第几个过滤器</span><br><span class="line">    private List&lt;Filter&gt; filters &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public FilterChain add(Filter filter) &#123;</span><br><span class="line">        filters.add(filter);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void doFilter(Request request, Response response) &#123;</span><br><span class="line">        if (index &#x3D;&#x3D; filters.size()) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        Filter filter &#x3D; filters.get(index);</span><br><span class="line">        index++;</span><br><span class="line">        filter.doFilter(request, response,this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class FaceFilter implements Filter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(Request request, Response response, FilterChain chain) &#123;</span><br><span class="line">        request.str &#x3D; (request.str.replace(&quot;:)&quot;, &quot;^V^&quot;));</span><br><span class="line">        chain.doFilter(request,response);</span><br><span class="line">        response.str +&#x3D; &quot;---FaceFilter()&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class HTMLFilter implements Filter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(Request request, Response response, FilterChain chain) &#123;</span><br><span class="line">        request.str &#x3D; request.str.replace(&quot;&lt;&quot;, &quot;[&quot;);</span><br><span class="line">        request.str &#x3D; request.str.replace(&quot;&gt;&quot;, &quot;]&quot;);</span><br><span class="line">        chain.doFilter(request,response);</span><br><span class="line">        response.str +&#x3D; &quot;---HTMLFilter()&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class HttpFilter implements Filter&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(Request request, Response response, FilterChain chain) &#123;</span><br><span class="line">        request.str &#x3D; request.str.replace(&quot;roqy.com&quot;, &quot;https:&#x2F;&#x2F;www.roqy.com&quot;);</span><br><span class="line">        response.str+&#x3D;&quot;---HttpFilter()&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>整个责任链模式，类似于一个递归的过程，每一个filter都传入了一个chain引用，在当前filter当中选择性的决定是否要调用下一个filter，在chain中维护着当前调用的filter在集合中的位置。当没有filter再去主动调用的时候就会自动倒序调用response。执行顺序request1-&gt;request2-&gt;request3 -&gt;response3-&gt;response2-&gt;response1。</p>
<p>优点：可以对请求者和处理者关系解耦，提高代码灵活性</p>
<p>缺点：在对链中请求处理者的遍历，如果处理者太多那么遍历就必定会影响性能，在一些递归中调用要慎重。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代器模式</title>
    <url>/2017/11/20/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="迭代器模式-iterator-："><a href="#迭代器模式-iterator-：" class="headerlink" title="迭代器模式(iterator)："></a>迭代器模式(iterator)：</h2><h5 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h5><p>每个集合或者容器的遍历方式不同，所以各自集合的遍历方式交给各自集合自己实现，但抽象出遍历器，每个集合都有自己的遍历器，遍历器获取方式相同。</p>
<a id="more"></a>

<h5 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h5><p>类图：</p>
<p><img src="image-20200808214016102.png" alt="image-20200808214016102"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Collection collection &#x3D; new ArrayList_();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">            collection.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">&#x2F;&#x2F;        System.out.println(collection.size());</span><br><span class="line"></span><br><span class="line">        Iterator iterator &#x3D; collection.iterator();</span><br><span class="line">        while (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ArrayList_&lt;E&gt; implements Collection&lt;E&gt; &#123;</span><br><span class="line">    private E[] list &#x3D; (E[])new Object[10];</span><br><span class="line">    private int index;</span><br><span class="line"></span><br><span class="line">    public void add(E o) &#123;</span><br><span class="line">        if (index &#x3D;&#x3D; list.length) &#123;</span><br><span class="line">            E[] newList &#x3D; (E[])new Object[list.length * 2];</span><br><span class="line">            System.arraycopy(list, 0, newList, 0, list.length);</span><br><span class="line">            list &#x3D; newList;</span><br><span class="line">        &#125;</span><br><span class="line">        list[index] &#x3D; o;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Iterator iterator() &#123;</span><br><span class="line">        return new ArrayListIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class ArrayListIterator implements Iterator &#123;</span><br><span class="line">        private int currentIndex &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean hasNext() &#123;</span><br><span class="line">            if (currentIndex &gt;&#x3D; index)</span><br><span class="line">                return false;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Object next() &#123;</span><br><span class="line">            Object o &#x3D; list[currentIndex];</span><br><span class="line">            currentIndex++;</span><br><span class="line">            return o;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class LikeList implements Collection &#123;</span><br><span class="line">    Node head, tail;</span><br><span class="line">    private int size;</span><br><span class="line"></span><br><span class="line">    private class Node&lt;E&gt; &#123;</span><br><span class="line">        private E o;</span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        public Node(E o) &#123;</span><br><span class="line">            this.o &#x3D; o;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void add(Object o) &#123;</span><br><span class="line">        Node node &#x3D; new Node(o);</span><br><span class="line">        node.next &#x3D; null;</span><br><span class="line">        if (head &#x3D;&#x3D; null) &#123;</span><br><span class="line">            head &#x3D; tail &#x3D; node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tail.next &#x3D; node;</span><br><span class="line">        tail &#x3D; node;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Iterator iterator() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Collection&lt;E&gt; &#123;</span><br><span class="line">    void add(E e);</span><br><span class="line"></span><br><span class="line">    int size();</span><br><span class="line"></span><br><span class="line">    Iterator iterator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Iterator&lt;E&gt; &#123;</span><br><span class="line">    boolean hasNext();</span><br><span class="line"></span><br><span class="line">    E next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>迭代器模式主要是用在集合中的遍历中，不做其他过多总结。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Retrofit源码分析</title>
    <url>/2021/02/18/Retrofit%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>Retrofit2.9.0</p>
<h1 id="一、基本概念及使用："><a href="#一、基本概念及使用：" class="headerlink" title="一、基本概念及使用："></a>一、基本概念及使用：</h1><h2 id="1、概念："><a href="#1、概念：" class="headerlink" title="1、概念："></a>1、概念：</h2><p>​        Retrofit是对OkHttp的进一步封装，内部使用了大量的设计模式，注解和反射</p>
<h2 id="2、基本使用："><a href="#2、基本使用：" class="headerlink" title="2、基本使用："></a>2、基本使用：</h2><p>​        gradle引用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">implementation(&quot;com.squareup.retrofit2:retrofit:2.9.0&quot;)</span><br><span class="line">implementation(&quot;com.squareup.retrofit2:converter-gson:2.9.0&quot;)</span><br></pre></td></tr></table></figure>

<p>​        代码使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> val retrofit &#x3D; Retrofit.Builder().baseUrl(&quot;&quot;)</span><br><span class="line">            .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">&#x2F;&#x2F;            .addCallAdapterFactory()</span><br><span class="line">            .build()</span><br><span class="line">        val clientService &#x3D; retrofit.create(ServerService::class.java)</span><br><span class="line"></span><br><span class="line">        clientService.getUserInfo(&quot;test&quot;).enqueue(object :Callback&lt;Response&lt;String&gt;&gt;&#123;</span><br><span class="line">            override fun onFailure(call: Call&lt;Response&lt;String&gt;&gt;, t: Throwable) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            override fun onResponse(call: Call&lt;Response&lt;String&gt;&gt;,response: Response&lt;Response&lt;String&gt;&gt;) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<h1 id="二、源码分析："><a href="#二、源码分析：" class="headerlink" title="二、源码分析："></a>二、源码分析：</h1><p>​    看源码最好从最后一句开始去看，这样才有目的性，切记不要去纠结源码细节，否则会陷进去出不来</p>
<h2 id="1、enqueue-："><a href="#1、enqueue-：" class="headerlink" title="1、enqueue()："></a>1、enqueue()：</h2><p>​       clientService.getUserInfo(“test”).enqueue()，进去之后会发现这是个接口中的方法，那么这里就看不了了</p>
<h2 id="2、clientService-getUserInfo-“test”"><a href="#2、clientService-getUserInfo-“test”" class="headerlink" title="2、clientService.getUserInfo(“test”)"></a>2、clientService.getUserInfo(“test”)</h2><p>​       因为前面走不下去，那么再看他前面一句：clientService.getUserInfo(“test”)，这个方法只是我们自己定义的Service中的接口方法</p>
<h2 id="3、retrofit-create-ServerService-class-java"><a href="#3、retrofit-create-ServerService-class-java" class="headerlink" title="3、retrofit.create(ServerService::class.java)"></a>3、retrofit.create(ServerService::class.java)</h2><p>因为前面都是接口方法，所以我们只能再去看前面的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">retrofit.create(ServerService::class.java)</span><br><span class="line"></span><br><span class="line">  public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123;</span><br><span class="line">    &#x2F;&#x2F;这个方法是去校验传入的service是不是接口</span><br><span class="line">    validateServiceInterface(service);</span><br><span class="line">    &#x2F;&#x2F;通过动态代理创建传入的service对象的代理对象，这里返回的就是这个代理对象</span><br><span class="line">    return (T)</span><br><span class="line">        Proxy.newProxyInstance(</span><br><span class="line">            &#x2F;&#x2F;传入一个ClassLoader</span><br><span class="line">            service.getClassLoader(),</span><br><span class="line">            &#x2F;&#x2F;传入我们需要代理的接口，可以是多个</span><br><span class="line">            new Class&lt;?&gt;[] &#123;service&#125;,</span><br><span class="line">            &#x2F;&#x2F;新建一个InvocationHandler，会重写invoke()</span><br><span class="line">            new InvocationHandler() &#123;</span><br><span class="line">            &#x2F;&#x2F;获取平台方法，平台方法不会走反射解析的方法</span><br><span class="line">              private final Platform platform &#x3D; Platform.get();</span><br><span class="line">              private final Object[] emptyArgs &#x3D; new Object[0];</span><br><span class="line"></span><br><span class="line">              @Override</span><br><span class="line">              public @Nullable Object invoke(Object proxy, Method method, @Nullable Object[] args)</span><br><span class="line">                  throws Throwable &#123;</span><br><span class="line">                &#x2F;&#x2F; If the method is a method from Object then defer to normal invocation.</span><br><span class="line">                if (method.getDeclaringClass() &#x3D;&#x3D; Object.class) &#123;</span><br><span class="line">                  return method.invoke(this, args);</span><br><span class="line">                &#125;</span><br><span class="line">                args &#x3D; args !&#x3D; null ? args : emptyArgs;</span><br><span class="line">                return platform.isDefaultMethod(method)</span><br><span class="line">                    ? platform.invokeDefaultMethod(method, service, proxy, args)</span><br><span class="line">                    &#x2F;&#x2F;自己定义的方法，会先看缓存中存不存在，如果不存在，则会对方法的各种注解和参数进行解析，解析完之后返回一个ServiceMethod</span><br><span class="line">                    : loadServiceMethod(method).invoke(args);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、ServiceMethod-lt-gt-loadServiceMethod-Method-method"><a href="#4、ServiceMethod-lt-gt-loadServiceMethod-Method-method" class="headerlink" title="4、ServiceMethod&lt;?&gt; loadServiceMethod(Method method)"></a>4、ServiceMethod&lt;?&gt; loadServiceMethod(Method method)</h2><p>解析接口当中的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ServiceMethod&lt;?&gt; loadServiceMethod(Method method) &#123;</span><br><span class="line">&#x2F;&#x2F;先看缓存中是否存在，存在直接返回</span><br><span class="line">  ServiceMethod&lt;?&gt; result &#x3D; serviceMethodCache.get(method);</span><br><span class="line">  if (result !&#x3D; null) return result;</span><br><span class="line">  </span><br><span class="line">  synchronized (serviceMethodCache) &#123;</span><br><span class="line">  &#x2F;&#x2F;在多线程情况下，在解析之前再从缓存中获取一次</span><br><span class="line">    result &#x3D; serviceMethodCache.get(method);</span><br><span class="line">    if (result &#x3D;&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F;开始真正的解析</span><br><span class="line">      result &#x3D; ServiceMethod.parseAnnotations(this, method);</span><br><span class="line">      &#x2F;&#x2F;解析完之后将解析之后的结果存到缓存方便下次使用</span><br><span class="line">      serviceMethodCache.put(method, result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5、ServiceMethod-parseAnnotations-："><a href="#5、ServiceMethod-parseAnnotations-：" class="headerlink" title="5、ServiceMethod#parseAnnotations()："></a>5、ServiceMethod#parseAnnotations()：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static &lt;T&gt; ServiceMethod&lt;T&gt; parseAnnotations(Retrofit retrofit, Method method) &#123;</span><br><span class="line">&#x2F;&#x2F;解析接口上的方法的注解</span><br><span class="line">  RequestFactory requestFactory &#x3D; RequestFactory.parseAnnotations(retrofit, method);</span><br><span class="line"></span><br><span class="line">  Type returnType &#x3D; method.getGenericReturnType();</span><br><span class="line">  if (Utils.hasUnresolvableType(returnType)) &#123;</span><br><span class="line">    throw methodError(</span><br><span class="line">        method,</span><br><span class="line">        &quot;Method return type must not include a type variable or wildcard: %s&quot;,</span><br><span class="line">        returnType);</span><br><span class="line">  &#125;</span><br><span class="line">  if (returnType &#x3D;&#x3D; void.class) &#123;</span><br><span class="line">    throw methodError(method, &quot;Service methods cannot return void.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6、RequestFactory-parseAnnotations-："><a href="#6、RequestFactory-parseAnnotations-：" class="headerlink" title="6、RequestFactory#parseAnnotations()："></a>6、RequestFactory#parseAnnotations()：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static RequestFactory parseAnnotations(Retrofit retrofit, Method method) &#123;</span><br><span class="line">&#x2F;&#x2F;这里采用了建造者模式，来构建RequestFactory</span><br><span class="line">  return new Builder(retrofit, method).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7、RequestFactory-parseMethodAnnotation-："><a href="#7、RequestFactory-parseMethodAnnotation-：" class="headerlink" title="7、RequestFactory# parseMethodAnnotation()："></a>7、RequestFactory# parseMethodAnnotation()：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void parseMethodAnnotation(Annotation annotation) &#123;</span><br><span class="line">    &#x2F;&#x2F;省略部分代码....</span><br><span class="line">    &#x2F;&#x2F;这里会解析不同的http的请求方法，这里只对get请求做分析</span><br><span class="line">     else if (annotation instanceof GET) &#123;</span><br><span class="line">       parseHttpMethodAndPath(&quot;GET&quot;, ((GET) annotation).value(), false);</span><br><span class="line">     &#125; </span><br><span class="line">      &#x2F;&#x2F;省略部分代码....</span><br><span class="line">     else if (annotation instanceof HTTP) &#123;</span><br><span class="line">       HTTP http &#x3D; (HTTP) annotation;</span><br><span class="line">       parseHttpMethodAndPath(http.method(), http.path(), http.hasBody());</span><br><span class="line">     &#125; else if (annotation instanceof retrofit2.http.Headers) &#123;</span><br><span class="line">       String[] headersToParse &#x3D; ((retrofit2.http.Headers) annotation).value();</span><br><span class="line">       if (headersToParse.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">         throw methodError(method, &quot;@Headers annotation is empty.&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       headers &#x3D; parseHeaders(headersToParse);</span><br><span class="line">     &#125; else if (annotation instanceof Multipart) &#123;</span><br><span class="line">       if (isFormEncoded) &#123;</span><br><span class="line">         throw methodError(method, &quot;Only one encoding annotation is allowed.&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       isMultipart &#x3D; true;</span><br><span class="line">     &#125; else if (annotation instanceof FormUrlEncoded) &#123;</span><br><span class="line">       if (isMultipart) &#123;</span><br><span class="line">         throw methodError(method, &quot;Only one encoding annotation is allowed.&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       isFormEncoded &#x3D; true;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="8、RequestFactory-parseHttpMethodAndPath"><a href="#8、RequestFactory-parseHttpMethodAndPath" class="headerlink" title="8、RequestFactory#parseHttpMethodAndPath():"></a>8、RequestFactory#parseHttpMethodAndPath():</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void parseHttpMethodAndPath(String httpMethod, String value, boolean hasBody) &#123;</span><br><span class="line">  if (this.httpMethod !&#x3D; null) &#123;</span><br><span class="line">    throw methodError(</span><br><span class="line">        method,</span><br><span class="line">        &quot;Only one HTTP method is allowed. Found: %s and %s.&quot;,</span><br><span class="line">        this.httpMethod,</span><br><span class="line">        httpMethod);</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;将方法进行保存，并记录了是否有请求体</span><br><span class="line">  this.httpMethod &#x3D; httpMethod;</span><br><span class="line">  this.hasBody &#x3D; hasBody;</span><br><span class="line">   &#x2F;&#x2F;如果这个请求方法注解中没有value，直接返回</span><br><span class="line">  if (value.isEmpty()) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 看这个请求方法注解中是否存在?</span><br><span class="line">  int question &#x3D; value.indexOf(&#39;?&#39;);</span><br><span class="line">  if (question !&#x3D; -1 &amp;&amp; question &lt; value.length() - 1) &#123;</span><br><span class="line">    &#x2F;&#x2F; Ensure the query string does not have any named parameters.</span><br><span class="line">    String queryParams &#x3D; value.substring(question + 1);</span><br><span class="line">    Matcher queryParamMatcher &#x3D; PARAM_URL_REGEX.matcher(queryParams);</span><br><span class="line">    if (queryParamMatcher.find()) &#123;</span><br><span class="line">      throw methodError(</span><br><span class="line">          method,</span><br><span class="line">          &quot;URL query string \&quot;%s\&quot; must not have replace block. &quot;</span><br><span class="line">              + &quot;For dynamic query parameters use @Query.&quot;,</span><br><span class="line">          queryParams);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.relativeUrl &#x3D; value;</span><br><span class="line">  &#x2F;&#x2F;解析了注解当中的value当中的参数信息</span><br><span class="line">  this.relativeUrlParamNames &#x3D; parsePathParameters(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9、HttpServiceMethod-parseAnnotations-："><a href="#9、HttpServiceMethod-parseAnnotations-：" class="headerlink" title="9、HttpServiceMethod.parseAnnotations()："></a>9、HttpServiceMethod.parseAnnotations()：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HttpServiceMethod实现了ServiceMethod这个抽象类，里面实现了invoke()，在前面我们就是想要找到这个invoke()是怎么执行的</span><br><span class="line"></span><br><span class="line">final @Nullable ReturnT invoke(Object[] args) &#123;</span><br><span class="line">&#x2F;&#x2F;创建了一个Retrofit的OkHttpCall</span><br><span class="line">    Call&lt;ResponseT&gt; call &#x3D; new OkHttpCall&lt;&gt;(requestFactory, args, callFactory, responseConverter);</span><br><span class="line">    &#x2F;&#x2F;交给了一个adapter，adapter在初始化Retrofit时如果我们没有add过，会有个默认的adapter，用来将执行结果切换到主线程的</span><br><span class="line">    return adapt(call, args);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="10、默认的adapter："><a href="#10、默认的adapter：" class="headerlink" title="10、默认的adapter："></a>10、默认的adapter：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">platform.defaultCallAdapterFactories(callbackExecutor)会传入一个默认的callbackExecutor</span><br><span class="line">    static final class MainThreadExecutor implements Executor &#123;</span><br><span class="line">    &#x2F;&#x2F;创建一个主线程的handler</span><br><span class="line">      private final Handler handler &#x3D; new Handler(Looper.getMainLooper());</span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      public void execute(Runnable r) &#123;</span><br><span class="line">        handler.post(r);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="11、如果没有添加新的adapter"><a href="#11、如果没有添加新的adapter" class="headerlink" title="11、如果没有添加新的adapter"></a>11、如果没有添加新的adapter</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public Type responseType() &#123;</span><br><span class="line">        return responseType;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      public Call&lt;Object&gt; adapt(Call&lt;Object&gt; call) &#123;</span><br><span class="line">      &#x2F;&#x2F;这里会将之前创建的Retrofit的OkHttpCall传进来，并交给Executor执行</span><br><span class="line">        return executor &#x3D;&#x3D; null ? call : new ExecutorCallbackCall&lt;&gt;(executor, call);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>12、当在使用Retrofit时，得到Call时并调用enqueue()时，在没有添加任何新的CallAdapter时，那么得到的就是这个默认的Adapter内部的一个ExecutorCallbackCall：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void enqueue(final Callback&lt;T&gt; callback) &#123;</span><br><span class="line">  Objects.requireNonNull(callback, &quot;callback &#x3D;&#x3D; null&quot;);</span><br><span class="line">   &#x2F;&#x2F;这个delegate就是在前面invoke()方法中创建的Retrofit的OkHttpCall</span><br><span class="line">  delegate.enqueue(</span><br><span class="line">      new Callback&lt;T&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onResponse(Call&lt;T&gt; call, final Response&lt;T&gt; response) &#123;</span><br><span class="line">         </span><br><span class="line">          callbackExecutor.execute(</span><br><span class="line">              () -&gt; &#123;</span><br><span class="line">              &#x2F;&#x2F;将执行结果切换到主线程中去</span><br><span class="line">                if (delegate.isCanceled()) &#123;</span><br><span class="line">                  callback.onFailure(ExecutorCallbackCall.this, new IOException(&quot;Canceled&quot;));</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                  callback.onResponse(ExecutorCallbackCall.this, response);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onFailure(Call&lt;T&gt; call, final Throwable t) &#123;</span><br><span class="line">          callbackExecutor.execute(() -&gt; callback.onFailure(ExecutorCallbackCall.this, t));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>​        retrofit是对OkHttp的进一步封装，里面用到了大量的设计模式进行解耦，内部涉及的设计模式：<br>​            1、Retrofit做为整个项目的门面，用到了门面模式<br>​            2、在配置Adapter或者Convert时用到了工厂方法<br>​            3、在创建Retrofit时用到了建造者模式<br>​            4、在调用create()方法时用到了动态代理<br>​            5、在查找合适的adapter的时候用到了策略模式，通过returnType去查找合适的adapter<br>​            6、通过adapter的adapt()转换时，用到了适配模式<br>​            7、在adapter的adapt()中，会传入一个call，传入的call是原始的call，这里用到了静态代理模式<br>​        我们知道之前在使用okHttp的时候需要配置各种requestBody、请求方法等等信息，这些都是很琐碎的事，retrofit通过大量的注解+反射的方式来帮我们动态的做了这些事<br>​        所以retrofit只是一个对okHttp进一步封装的封装框架，而不是网络框架真正做网络处理的是okHttp</p>
]]></content>
      <tags>
        <tag>第三方 源码</tag>
      </tags>
  </entry>
  <entry>
    <title>blockcanary1.5源码分析</title>
    <url>/2021/01/13/blockcanary1-5%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="一、基本使用："><a href="#一、基本使用：" class="headerlink" title="一、基本使用："></a>一、基本使用：</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">debugImplementation &#39;com.github.markzhai:blockcanary-android:1.5.0&#39;</span><br></pre></td></tr></table></figure>

<p>在自己的Application的onCreate()中添入下面语句:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BlockCanary.install(this, BlockCanaryContext()).start()</span><br></pre></td></tr></table></figure>

<h1 id="二、源码分析："><a href="#二、源码分析：" class="headerlink" title="二、源码分析："></a>二、源码分析：</h1><h2 id="2-1、BlockCanary-install-："><a href="#2-1、BlockCanary-install-：" class="headerlink" title="2.1、BlockCanary.install()："></a>2.1、BlockCanary.install()：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static BlockCanary install(Context context, BlockCanaryContext blockCanaryContext) &#123;</span><br><span class="line">&#x2F;&#x2F;将两个上下文进行了保存</span><br><span class="line">    BlockCanaryContext.init(context, blockCanaryContext);</span><br><span class="line">    setEnabled(context, DisplayActivity.class, BlockCanaryContext.get().displayNotification());</span><br><span class="line">    &#x2F;&#x2F;获取一个单例的BlockCanary</span><br><span class="line">    return get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>install方法内部比较简单，就是将上下文进行了保存，并得到了一个单例的BlockCanary，接下来我们就看下BlockCanary的构造函数</p>
<h2 id="2-2、BlockCanary构造函数："><a href="#2-2、BlockCanary构造函数：" class="headerlink" title="2.2、BlockCanary构造函数："></a>2.2、BlockCanary构造函数：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private BlockCanary() &#123;</span><br><span class="line">&#x2F;&#x2F;得到一个BlockCanaryInternals</span><br><span class="line">    mBlockCanaryCore &#x3D; BlockCanaryInternals.getInstance();</span><br><span class="line">    mBlockCanaryCore.addBlockInterceptor(BlockCanaryContext.get());</span><br><span class="line">    if (!BlockCanaryContext.get().displayNotification()) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    mBlockCanaryCore.addBlockInterceptor(new DisplayService());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3、BlockCanaryInternals构造函数："><a href="#2-3、BlockCanaryInternals构造函数：" class="headerlink" title="2.3、BlockCanaryInternals构造函数："></a>2.3、BlockCanaryInternals构造函数：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public BlockCanaryInternals() &#123;</span><br><span class="line">    &#x2F;&#x2F;获取堆栈信息的采样器</span><br><span class="line">    stackSampler &#x3D; new StackSampler(</span><br><span class="line">            Looper.getMainLooper().getThread(),</span><br><span class="line">            sContext.provideDumpInterval());</span><br><span class="line">    &#x2F;&#x2F;获取cpu信息的采样器</span><br><span class="line">    cpuSampler &#x3D; new CpuSampler(sContext.provideDumpInterval());</span><br><span class="line">    &#x2F;&#x2F;匿名的LooperMonitor，实现了Printer</span><br><span class="line">    setMonitor(new LooperMonitor(new LooperMonitor.BlockListener() &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onBlockEvent(long realTimeStart, long realTimeEnd,</span><br><span class="line">                                 long threadTimeStart, long threadTimeEnd) &#123;</span><br><span class="line">            &#x2F;&#x2F; Get recent thread-stack entries and cpu usage</span><br><span class="line">            ArrayList&lt;String&gt; threadStackEntries &#x3D; stackSampler</span><br><span class="line">                    .getThreadStackEntries(realTimeStart, realTimeEnd);</span><br><span class="line">            if (!threadStackEntries.isEmpty()) &#123;</span><br><span class="line">                BlockInfo blockInfo &#x3D; BlockInfo.newInstance()</span><br><span class="line">                        .setMainThreadTimeCost(realTimeStart, realTimeEnd, threadTimeStart, threadTimeEnd)</span><br><span class="line">                        .setCpuBusyFlag(cpuSampler.isCpuBusy(realTimeStart, realTimeEnd))</span><br><span class="line">                        .setRecentCpuRate(cpuSampler.getCpuRateInfo())</span><br><span class="line">                        .setThreadStackEntries(threadStackEntries)</span><br><span class="line">                        .flushString();</span><br><span class="line">                &#x2F;&#x2F;将采集到的堆栈信息和cpu信息保存到文件中</span><br><span class="line">                LogWriter.save(blockInfo.toString());</span><br><span class="line"></span><br><span class="line">                if (mInterceptorChain.size() !&#x3D; 0) &#123;</span><br><span class="line">                    for (BlockInterceptor interceptor : mInterceptorChain) &#123;</span><br><span class="line">                        interceptor.onBlock(getContext().provideContext(), blockInfo);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, getContext().provideBlockThreshold(), getContext().stopWhenDebugging()));</span><br><span class="line"></span><br><span class="line">    LogWriter.cleanObsolete();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4、start-："><a href="#2-4、start-：" class="headerlink" title="2.4、start()："></a>2.4、start()：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void start() &#123;</span><br><span class="line">    if (!mMonitorStarted) &#123;</span><br><span class="line">        mMonitorStarted &#x3D; true;</span><br><span class="line">        &#x2F;&#x2F;将前面创建出来的实现了Printer接口的monitor给主线程的Looper使用</span><br><span class="line">        Looper.getMainLooper().setMessageLogging(mBlockCanaryCore.monitor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-5、为什么这样配置了就可以了？"><a href="#2-5、为什么这样配置了就可以了？" class="headerlink" title="2.5、为什么这样配置了就可以了？"></a>2.5、为什么这样配置了就可以了？</h2><p>到这里，我们只看到对blockcanary的基本配置，以及给Looper配置了一个Printer，为什么这样就可以完成卡顿的捕获了？这就得从我们的Handler去分析了。我们知道Handler是<br>android整个所有事件驱动者，包括UI上的各种显示等都会通过Handler来进行处理，而Looper是每一个线程都有的且唯一的，本身是通过ThreadLocal来保证了每个线程Looper的唯一性。<br>在主线程中会主动去调用Looper的loop()<br>在Looper.loop()中在所有事件开始之初有这样一段代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final Printer logging &#x3D; me.mLogging;</span><br><span class="line">      if (logging !&#x3D; null) &#123;</span><br><span class="line">          logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +</span><br><span class="line">                  msg.callback + &quot;: &quot; + msg.what);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>这里我们可以看到，在处理事件之前，会先调用Printer的println()，我们前面自定义了一个实现了Printer接口的Monitor，那么就会调用到我们自定义的Monitor的println()<br>在事件处理结束之后还有一段代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (logging !&#x3D; null) &#123;</span><br><span class="line">    logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 也就是说在所有事件处理结束的时候同样也会调用Printer的println()，那么我们要统计是否存在卡断，就可以统计这两次调用这个方法的时间间隔，就可以来判断是否存在卡顿<br>接下来我们继续看Monitor中的println()是如何处理的</p>
<h2 id="2-6、LooperMonitor-println-："><a href="#2-6、LooperMonitor-println-：" class="headerlink" title="2.6、LooperMonitor#println()："></a>2.6、LooperMonitor#println()：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void println(String x) &#123;</span><br><span class="line">&#x2F;&#x2F;如果是debug的就不进行卡顿分析</span><br><span class="line">    if (mStopWhenDebugging &amp;&amp; Debug.isDebuggerConnected()) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;mPrintingStarted是用来标记是否第一次调用了println()</span><br><span class="line">    if (!mPrintingStarted) &#123;&#x2F;&#x2F;一次事件中第一次调用</span><br><span class="line">        mStartTimestamp &#x3D; System.currentTimeMillis();</span><br><span class="line">        mStartThreadTimestamp &#x3D; SystemClock.currentThreadTimeMillis();</span><br><span class="line">        mPrintingStarted &#x3D; true;</span><br><span class="line">        &#x2F;&#x2F;里面收集堆栈信息喝cpu信息</span><br><span class="line">        startDump();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        final long endTime &#x3D; System.currentTimeMillis();</span><br><span class="line">        mPrintingStarted &#x3D; false;</span><br><span class="line">        &#x2F;&#x2F;如果事件开始的时间和事件执行结束的时间大于3s才进行分析</span><br><span class="line">        if (isBlock(endTime)) &#123;</span><br><span class="line">            notifyBlockEvent(endTime);</span><br><span class="line">        &#125;</span><br><span class="line">        stopDump();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-7、LooperMonitor-notifyBlockEvent-："><a href="#2-7、LooperMonitor-notifyBlockEvent-：" class="headerlink" title="2.7、LooperMonitor#notifyBlockEvent()："></a>2.7、LooperMonitor#notifyBlockEvent()：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  如果在主线程中出现了卡顿，才会调用这里</span><br><span class="line">private void notifyBlockEvent(final long endTime) &#123;</span><br><span class="line">    final long startTime &#x3D; mStartTimestamp;</span><br><span class="line">    final long startThreadTime &#x3D; mStartThreadTimestamp;</span><br><span class="line">    final long endThreadTime &#x3D; SystemClock.currentThreadTimeMillis();</span><br><span class="line">    &#x2F;&#x2F;得到一个在子线程运行的Handler</span><br><span class="line">    HandlerThreadFactory.getWriteLogThreadHandler().post(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">        &#x2F;&#x2F;这里会调用到BlockCanaryInternals构造函数当中创建的匿名函数当中</span><br><span class="line">            mBlockListener.onBlockEvent(startTime, endTime, startThreadTime, endThreadTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、总结："><a href="#三、总结：" class="headerlink" title="三、总结："></a>三、总结：</h1><p>​    1、对于blockcanary原理其实还是比较简单的，就是利用了handler在处理事件的开始和结束都会调用Printer的println()，在一次事件的处理过程中判断两次调用的时间间隔<br>​    通过判断这个时间间隔来判断是否存在卡顿。<br>​    2、对于CPU信息的收集，就是对配置文件当中的内容进行了读取操作</p>
]]></content>
      <tags>
        <tag>第三方源码</tag>
      </tags>
  </entry>
  <entry>
    <title>leakcanary2.6源码分析</title>
    <url>/2021/02/13/leakcanary%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="一、leakcanary配置："><a href="#一、leakcanary配置：" class="headerlink" title="一、leakcanary配置："></a>一、leakcanary配置：</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  &#x2F;&#x2F; 只需要在测试阶段使用，所以只配置debug的</span><br><span class="line">  debugImplementation &#39;com.squareup.leakcanary:leakcanary-android:2.6&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二、源码分析："><a href="#二、源码分析：" class="headerlink" title="二、源码分析："></a>二、源码分析：</h1><p>在2.4以前都需要手动去注册leakcanary，之后就将这个自动注册的功能放在了provider当中，在配置完leakcanary之后可以在jetified-leakcanary-object-watcher-android-2.6/AndroidManifest.xml中可以看到有一个注册的provider AppWatcherInstaller<br>    provider之所以比Application的onCreate()先执行，我们可以从ActivityThread里的H中handleMessage找到答案</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">case BIND_APPLICATION:</span><br><span class="line">         Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;bindApplication&quot;);</span><br><span class="line">         AppBindData data &#x3D; (AppBindData)msg.obj;</span><br><span class="line">         handleBindApplication(data);</span><br><span class="line">         Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">         break;</span><br><span class="line">         </span><br><span class="line">   handleBindApplication():      </span><br><span class="line">   if (!data.restrictedBackupMode) &#123;</span><br><span class="line">        if (!ArrayUtils.isEmpty(data.providers)) &#123;</span><br><span class="line">            installContentProviders(app, data.providers);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   try &#123;</span><br><span class="line">        mInstrumentation.callApplicationOnCreate(app);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h2 id="AppWatcherInstaller-onCreate"><a href="#AppWatcherInstaller-onCreate" class="headerlink" title="AppWatcherInstaller#onCreate():"></a>AppWatcherInstaller#onCreate():</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override fun onCreate(): Boolean &#123;</span><br><span class="line">  val application &#x3D; context!!.applicationContext as Application</span><br><span class="line">  &#x2F;&#x2F;对监听器进行安装</span><br><span class="line">  AppWatcher.manualInstall(application)</span><br><span class="line">  return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AppWatcher-manualInstall-："><a href="#AppWatcher-manualInstall-：" class="headerlink" title="AppWatcher#manualInstall()："></a>AppWatcher#manualInstall()：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@JvmOverloads</span><br><span class="line">    fun manualInstall(</span><br><span class="line">      application: Application,</span><br><span class="line">      retainedDelayMillis: Long &#x3D; TimeUnit.SECONDS.toMillis(5),</span><br><span class="line">      watchersToInstall: List&lt;InstallableWatcher&gt; &#x3D; appDefaultWatchers(application)</span><br><span class="line">    ) &#123;</span><br><span class="line">      &#x2F;&#x2F;省略部分代码...</span><br><span class="line">      watchersToInstall.forEach &#123;</span><br><span class="line">        it.install()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure>

<h2 id="watchersToInstall"><a href="#watchersToInstall" class="headerlink" title="watchersToInstall:"></a>watchersToInstall:</h2><p> 就是一个List<InstallableWatcher>，具体内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ActivityWatcher(application, reachabilityWatcher),</span><br><span class="line">    FragmentAndViewModelWatcher(application, reachabilityWatcher),</span><br><span class="line">    RootViewWatcher(reachabilityWatcher),</span><br><span class="line">    ServiceWatcher(reachabilityWatcher)   </span><br><span class="line">    其实就是leakcanary默认支持的内存泄露检测的组件，我们只看一个Activity的注册：</span><br><span class="line">   ActivityWatcher#install()：</span><br><span class="line">    override fun install() &#123;</span><br><span class="line">       application.registerActivityLifecycleCallbacks(lifecycleCallbacks)</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">       private val lifecycleCallbacks &#x3D;</span><br><span class="line">         object : Application.ActivityLifecycleCallbacks by noOpDelegate() &#123;</span><br><span class="line">           override fun onActivityDestroyed(activity: Activity) &#123;</span><br><span class="line">           &#x2F;&#x2F;当activity执行onDestory()方法时，才会执行</span><br><span class="line">             reachabilityWatcher.expectWeaklyReachable(</span><br><span class="line">               activity, &quot;$&#123;activity::class.java.name&#125; received Activity#onDestroy() callback&quot;</span><br><span class="line">             )</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>

<h2 id="ObjectWatcher-expectWeaklyReachable-："><a href="#ObjectWatcher-expectWeaklyReachable-：" class="headerlink" title="ObjectWatcher#expectWeaklyReachable()："></a>ObjectWatcher#expectWeaklyReachable()：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Synchronized override fun expectWeaklyReachable(</span><br><span class="line">      watchedObject: Any,</span><br><span class="line">      description: String</span><br><span class="line">    ) &#123;</span><br><span class="line">      if (!isEnabled()) &#123;</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F;先将弱引用队列清空</span><br><span class="line">      removeWeaklyReachableObjects()</span><br><span class="line">      val key &#x3D; UUID.randomUUID()</span><br><span class="line">        .toString()</span><br><span class="line">      val watchUptimeMillis &#x3D; clock.uptimeMillis()</span><br><span class="line">      &#x2F;&#x2F;生成一个新的弱引用对象</span><br><span class="line">      val reference &#x3D;</span><br><span class="line">        KeyedWeakReference(watchedObject, key, description, watchUptimeMillis, queue)</span><br><span class="line">        &#x2F;&#x2F;将新的弱引用保存在map当中</span><br><span class="line">      watchedObjects[key] &#x3D; reference</span><br><span class="line">      checkRetainedExecutor.execute &#123;</span><br><span class="line">      &#x2F;&#x2F;移动需要保留的key</span><br><span class="line">        moveToRetained(key)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     @Synchronized private fun moveToRetained(key: String) &#123;</span><br><span class="line">     &#x2F;&#x2F;再清除了一次弱引用队列，如果map当中还存在，则这些就是内存泄漏得</span><br><span class="line">        removeWeaklyReachableObjects()</span><br><span class="line">        val retainedRef &#x3D; watchedObjects[key]</span><br><span class="line">        if (retainedRef !&#x3D; null) &#123;</span><br><span class="line">          retainedRef.retainedUptimeMillis &#x3D; clock.uptimeMillis()</span><br><span class="line">          &#x2F;&#x2F;对泄漏对象进行分析</span><br><span class="line">          onObjectRetainedListeners.forEach &#123; it.onObjectRetained() &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">       private fun removeWeaklyReachableObjects() &#123;</span><br><span class="line">      </span><br><span class="line">         var ref: KeyedWeakReference?</span><br><span class="line">         do &#123;</span><br><span class="line">         &#x2F;&#x2F;如果弱引用队列中存在，则将这个从map集合中移除掉，剩下的是可能存在泄漏风险的</span><br><span class="line">           ref &#x3D; queue.poll() as KeyedWeakReference?</span><br><span class="line">           if (ref !&#x3D; null) &#123;</span><br><span class="line">             watchedObjects.remove(ref.key)</span><br><span class="line">           &#125;</span><br><span class="line">         &#125; while (ref !&#x3D; null)</span><br><span class="line">       &#125;</span><br><span class="line">      </span><br></pre></td></tr></table></figure>

<h2 id="HeapDumpTrigger-checkRetainedObjects-："><a href="#HeapDumpTrigger-checkRetainedObjects-：" class="headerlink" title="HeapDumpTrigger#checkRetainedObjects()："></a>HeapDumpTrigger#checkRetainedObjects()：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private fun checkRetainedObjects() &#123;</span><br><span class="line">        &#x2F;&#x2F;省略部分代码...</span><br><span class="line">          var retainedReferenceCount &#x3D; objectWatcher.retainedObjectCount</span><br><span class="line">      </span><br><span class="line">          if (retainedReferenceCount &gt; 0) &#123;</span><br><span class="line">          &#x2F;&#x2F; 可能存在被观察的引用将要变得弱可达，但是还未入队引用队列。</span><br><span class="line">          &#x2F;&#x2F; 这时候应该主动调用一次 GC，可以避免一次 heap dump</span><br><span class="line">            gcTrigger.runGc()</span><br><span class="line">            retainedReferenceCount &#x3D; objectWatcher.retainedObjectCount</span><br><span class="line">          &#125;</span><br><span class="line">      </span><br><span class="line">          &#x2F;&#x2F;校验当前泄漏实例个数，最多不能超过5个，超过5个将不再进行dump</span><br><span class="line">          if (checkRetainedCount(retainedReferenceCount, config.retainedVisibleThreshold)) return</span><br><span class="line">      </span><br><span class="line">          val now &#x3D; SystemClock.uptimeMillis()</span><br><span class="line">          val elapsedSinceLastDumpMillis &#x3D; now - lastHeapDumpUptimeMillis</span><br><span class="line">          &#x2F;&#x2F;上一次dump的时间间隔如果小于60s，就延迟再执行这个dump</span><br><span class="line">          if (elapsedSinceLastDumpMillis &lt; WAIT_BETWEEN_HEAP_DUMPS_MILLIS) &#123;</span><br><span class="line">            onRetainInstanceListener.onEvent(DumpHappenedRecently)</span><br><span class="line">            showRetainedCountNotification(</span><br><span class="line">              objectCount &#x3D; retainedReferenceCount,</span><br><span class="line">              contentText &#x3D; application.getString(R.string.leak_canary_notification_retained_dump_wait)</span><br><span class="line">            )</span><br><span class="line">            scheduleRetainedObjectCheck(</span><br><span class="line">              delayMillis &#x3D; WAIT_BETWEEN_HEAP_DUMPS_MILLIS - elapsedSinceLastDumpMillis</span><br><span class="line">            )</span><br><span class="line">            return</span><br><span class="line">          &#125;</span><br><span class="line">      </span><br><span class="line">          dismissRetainedCountNotification()</span><br><span class="line">          val visibility &#x3D; if (applicationVisible) &quot;visible&quot; else &quot;not visible&quot;</span><br><span class="line"> </span><br><span class="line">          dumpHeap(</span><br><span class="line">            retainedReferenceCount &#x3D; retainedReferenceCount,</span><br><span class="line">            retry &#x3D; true,</span><br><span class="line">            reason &#x3D; &quot;$retainedReferenceCount retained objects, app is $visibility&quot;</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="GcTrigger-runGc-："><a href="#GcTrigger-runGc-：" class="headerlink" title="GcTrigger#runGc()："></a>GcTrigger#runGc()：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun runGc() &#123;</span><br><span class="line">           &#x2F;&#x2F;System.gc()内部也调用了Runtime().gc()，但在调用前做了处理，System.gc()在执行了一次之后不会再执行，所以这里使用Runtime.gc()</span><br><span class="line">            Runtime.getRuntime()</span><br><span class="line">              .gc()</span><br><span class="line">            enqueueReferences()</span><br><span class="line">            System.runFinalization()</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          </span><br><span class="line">      private fun dumpHeap(</span><br><span class="line">          retainedReferenceCount: Int,</span><br><span class="line">          retry: Boolean,</span><br><span class="line">          reason: String</span><br><span class="line">        ) &#123;</span><br><span class="line">          saveResourceIdNamesToMemory()</span><br><span class="line">          val heapDumpUptimeMillis &#x3D; SystemClock.uptimeMillis()</span><br><span class="line">          KeyedWeakReference.heapDumpUptimeMillis &#x3D; heapDumpUptimeMillis</span><br><span class="line">          when (val heapDumpResult &#x3D; heapDumper.dumpHeap()) &#123;</span><br><span class="line">           &#x2F;&#x2F;省略部分代码...</span><br><span class="line">            is HeapDump -&gt; &#123;</span><br><span class="line">              lastDisplayedRetainedObjectCount &#x3D; 0</span><br><span class="line">              lastHeapDumpUptimeMillis &#x3D; SystemClock.uptimeMillis()</span><br><span class="line">              &#x2F;&#x2F;先将这个引用从map中移除</span><br><span class="line">              objectWatcher.clearObjectsWatchedBefore(heapDumpUptimeMillis)</span><br><span class="line">              &#x2F;&#x2F;启动了一个前台的服务，进行真正内存分析操作，以前Square用的是haha的分析库，后来换成了一个全新的分析库shark，官方说这个库比之前的库快了6倍而且减少了90%的内存消耗</span><br><span class="line">              </span><br><span class="line">              HeapAnalyzerService.runAnalysis(</span><br><span class="line">                context &#x3D; application,</span><br><span class="line">                heapDumpFile &#x3D; heapDumpResult.file,</span><br><span class="line">                heapDumpDurationMillis &#x3D; heapDumpResult.durationMillis,</span><br><span class="line">                heapDumpReason &#x3D; reason</span><br><span class="line">              )</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">      对于这个库如何去分析的内存泄漏，就不再进行深究。</span><br></pre></td></tr></table></figure>

<h1 id="三、总结："><a href="#三、总结：" class="headerlink" title="三、总结："></a>三、总结：</h1><p>​    1、在Leakcanary的源码当中，我们学到了第三方库的初始化可以放到ContentProvider当中，就不需要我们再在Application当中去初始化<br>​    2、当引用发生回收时，会将这个引用添加到队列当中<br>​    3、在触发gc时通过Runtime.gc()去触发，并不是通过System.gc()触发，因为System.gc()可能只触发一次就不再触发<br>​    4、当进行dump的过程中，分析内存的时间间隔为60s，在没达到60s时会进行顺延<br>​    5、当泄漏实例超过5个，将不再进行dump操作<br>​    6、在进行内存分析的过程中，之前是用的haha的库，后面用了shark进行分析，且按照官方所说，shark的内存消耗降低了90%，速度快了6倍</p>
]]></content>
      <tags>
        <tag>第三方源码</tag>
      </tags>
  </entry>
</search>
